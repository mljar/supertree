
    <script src="https://cdn.jsdelivr.net/npm/d3@7" charset="utf-8"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util@0.15.1/nacl-util.min.js"></script>

    <style > .st-dropdown {

  border-radius: 0px; 
  background-color: #008CBA;
  border: 2px solid #007B9A;
  color: white;
  height: 50px;
  width: 125px;
  text-align: center;
  line-height: 1.5;
  font-size: 16px;
  cursor: pointer; 
  transition: background-color 0.3s, box-shadow 0.3s; 
  box-sizing: border-box;
  display: inline-block;

}

.st-option-button {
  border: 1px solid #007B9A;
  border-radius: 0px; 
  background-color: #008CBA;
  border: 2px solid #007B9A;
  color: white; 
  line-height: 1.5;
  height: 50px;
  width: 50px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  cursor: pointer; 
  transition: background-color 0.3s, box-shadow 0.3s; 
  align-items: center;
  justify-content: center;
  display: flex;
}


.st-option-button svg {
    margin: 0;
    padding: 0;
    vertical-align: middle;
}


.st-option-button:hover {
    background-color: #45a049;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.jp-RenderedHTMLCommon p {
    text-align: center;
    margin: 0;
    margin-bottom: 1em;
}

.st-info-div {
    align-items: center;     
}

.st-body-toolbar-div {
align-items: center;
display: flex; 
justify-content: center; 
  margin: 0;
  padding: 0;
  appearance: none; 
  line-height: normal;
  margin: 0;
  padding: 0.5em 1em;
  vertical-align: middle;
}

.st-toolbar {
align-items: center;
display: flex; 
justify-content: center; 
  margin: 0;
  padding: 0;
  appearance: none; 
  line-height: normal; 
  margin: 0;
  padding: 0.5em 1em; 
  vertical-align: middle;
}





.st-logo-button svg {
  width: 100%;
  height: 100%;
  vertical-align: middle; 
  margin: 0;
  margin-bottom: 0;
}



select {
    appearance: none; 
    text-align: center;
    box-sizing: border-box; 
}


option {

}






.st-svg {
  width: 100%;
  height: 1000px !important;
}


.st-svg-2 {
  width: 100%;
}



.st-target {
  font-family: lato;
  font-size: 10px;
  fill: #333333;
}


.st-pie-target {
  font-family: lato;
  font-size: 10px;
  fill: #333333;
}

.st-pie-target2 {
  font-family: lato;
  font-size: 10px;
  fill: #333333;
}

.st-grid path {
  stroke-width: 0;
  stroke: #333333;
}

.st-grid .tick line {
  stroke: #333333;
  stroke-width: 0.3px;
  stroke-opacity: 0.3;
}


.st-tooltip {
  background-color: #ffffff;
  font-family: lato;
  font-size: 11px;
  padding: 4px;
  color: #666666;
  border: none;
  box-shadow: 0px 0px 3px 0px #E6E6E6;
}

.st-modal {
    display: none; 
    position: fixed; 
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%; 
    height: 100%; 
    overflow: hidden; 
    background-color: rgba(0, 0, 0, 0.7); 
}


.st-modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 20px;
    border: 1px solid #888;
    width: 90%; 
    height: 90%;
    max-width: 90%;
    max-height: 90%;
    text-align: center;
    overflow: hidden;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex; 
    flex-direction: column;
}



.st-container {
    background-color: #fefefe;
    width: 100%; 
    height: 100vh;
    max-height: 825px;
    text-align: center;
    display: flex;
    overflow: hidden;
    flex-direction: column;
    gap: 0;
    padding: 0;
    margin: 0;
}


.st-body-tree-div {
  min-height: 1000px;
}


.st-logo {
  cursor: pointer;
  display: inline-block;
  margin: 0;
  padding: 0;
  position: absolute;
}




.st-container > div {
    margin: 0;
    padding: 0;
}



.st-closeBtn {
    color: #aaa;
    position: absolute;
    float: right;
    font-size: 28px;
    font-weight: bold;
    top: 10px;
    right: 20px;
}

.st-closeBtn:hover,
.st-closeBtn:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}



.st-logo-button {

  height: 100%;
  padding: 14px 28px;
  background: #008CBA;
  border: none;
  padding: 0;
  margin: 0;
  cursor: pointer;
  justify-content: center;
  align-items: center;


}

.st-link{
  stroke: #555;
}

#my-window {
    position: relative; 
}

.st-side-panel {
    width: 300px; 
   background-color: #f3f9fb;
    position: absolute;
    top: 0;
    right: -350px;
    padding: 10px;
    box-shadow: -2px 0 5px rgba(0,0,0,0.1);
    transition: right 0.3s ease;
    overflow: auto; 
    max-height: 100vh;
}

.st-side-panel.show {
    right: 0px;
}

.st-side-panel.hide {
    right: -350px; 
}



.st-openModal {
    background-color: #008CBA;
    border: 2px solid #007B9A;
    color: white; 
    padding: 14px 28px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 4px 2px;
    cursor: pointer; 
    border-radius: 8px; 
    transition: background-color 0.3s, box-shadow 0.3s; 
}

.st-openModal:hover {
    background-color: #45a049;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.st-close-button {
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 24px;
    cursor: pointer;
    color: #000;
}

.st-tree-div {
    flex-grow: 1; 
    display: flex;
    justify-content: center; 
    align-items: center;
}


.yAxis{
  color: #000000;
}

.xAxis-text {
  color: #000000;
}
 </style>
    <html>

    <div id="my-window" class="st-container">
        <div id="st-info-div-36082" class="st-info-div"></div>
        <div id="toolbar-36082" class="st-body-toolbar-div"></div>
        <div id="graph-div-36082" class="st-body-tree-div-36082"></div>
      <div id="st-side-panel-36082" class="st-side-panel">
            <span id="st-close-button-36082" class="st-close-button">&times;</span>
        <div>
    </div>
    </html>
    <script > var DEBUG_LEVEL = "debug";

function stLog(level, obj, message = "Data;") {
  const levels = ["debug", "custom", "info", "warning", "error"];

  if (levels.indexOf(level) >= levels.indexOf(DEBUG_LEVEL)) {
    console.log(`[${level.toUpperCase()}]:`, message, obj);
  }
}

function buildTree(
  Key = "key",
  pathJson = "data/bug.json",
  pytree = {"node_data": {"feature": 3, "threshold": 0.8, "impurity": 0.667, "samples": 150, "class_distribution": [[50.0, 50.0, 50.0]], "treeclass": "setosa", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 50, "class_distribution": [[50.0, 0.0, 0.0]], "treeclass": "setosa", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], [0.8, "notexist"]], "left_node": null, "right_node": null}, "right_node": {"feature": 3, "threshold": 1.75, "impurity": 0.5, "samples": 100, "class_distribution": [[0.0, 50.0, 50.0]], "treeclass": "versicolor", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 0.8]], "left_node": {"feature": 2, "threshold": 4.95, "impurity": 0.168, "samples": 54, "class_distribution": [[0.0, 49.0, 5.0]], "treeclass": "versicolor", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], [1.75, 0.8]], "left_node": {"feature": 3, "threshold": 1.65, "impurity": 0.041, "samples": 48, "class_distribution": [[0.0, 47.0, 1.0]], "treeclass": "versicolor", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [4.95, "notexist"], [1.75, 0.8]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 47, "class_distribution": [[0.0, 47.0, 0.0]], "treeclass": "versicolor", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [4.95, "notexist"], [1.65, 0.8]], "left_node": null, "right_node": null}, "right_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 1, "class_distribution": [[0.0, 0.0, 1.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [4.95, "notexist"], [1.75, 1.65]], "left_node": null, "right_node": null}}, "right_node": {"feature": 3, "threshold": 1.55, "impurity": 0.444, "samples": 6, "class_distribution": [[0.0, 2.0, 4.0]], "treeclass": "virginica", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 4.95], [1.75, 0.8]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 3, "class_distribution": [[0.0, 0.0, 3.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 4.95], [1.55, 0.8]], "left_node": null, "right_node": null}, "right_node": {"feature": 2, "threshold": 5.45, "impurity": 0.444, "samples": 3, "class_distribution": [[0.0, 2.0, 1.0]], "treeclass": "versicolor", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 4.95], [1.75, 1.55]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 2, "class_distribution": [[0.0, 2.0, 0.0]], "treeclass": "versicolor", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [5.45, 4.95], [1.75, 1.55]], "left_node": null, "right_node": null}, "right_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 1, "class_distribution": [[0.0, 0.0, 1.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 5.45], [1.75, 1.55]], "left_node": null, "right_node": null}}}}, "right_node": {"feature": 2, "threshold": 4.85, "impurity": 0.043, "samples": 46, "class_distribution": [[0.0, 1.0, 45.0]], "treeclass": "virginica", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 1.75]], "left_node": {"feature": 0, "threshold": 5.95, "impurity": 0.444, "samples": 3, "class_distribution": [[0.0, 1.0, 2.0]], "treeclass": "virginica", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [4.85, "notexist"], ["notexist", 1.75]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 1, "class_distribution": [[0.0, 1.0, 0.0]], "treeclass": "versicolor", "is_leaf": true, "start_end_x_axis": [[5.95, "notexist"], ["notexist", "notexist"], [4.85, "notexist"], ["notexist", 1.75]], "left_node": null, "right_node": null}, "right_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 2, "class_distribution": [[0.0, 0.0, 2.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", 5.95], ["notexist", "notexist"], [4.85, "notexist"], ["notexist", 1.75]], "left_node": null, "right_node": null}}, "right_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 43, "class_distribution": [[0.0, 0.0, 43.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 4.85], ["notexist", 1.75]], "left_node": null, "right_node": null}}}}, "tree_data": {"tree_type": "classification", "feature_names": ["sepal length (cm)", "sepal width (cm)", "petal length (cm)", "petal width (cm)"], "target_names": ["setosa", "versicolor", "virginica"], "data_feature": [[5.1, 3.5, 1.4, 0.2], [4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2], [4.6, 3.1, 1.5, 0.2], [5.0, 3.6, 1.4, 0.2], [5.4, 3.9, 1.7, 0.4], [4.6, 3.4, 1.4, 0.3], [5.0, 3.4, 1.5, 0.2], [4.4, 2.9, 1.4, 0.2], [4.9, 3.1, 1.5, 0.1], [5.4, 3.7, 1.5, 0.2], [4.8, 3.4, 1.6, 0.2], [4.8, 3.0, 1.4, 0.1], [4.3, 3.0, 1.1, 0.1], [5.8, 4.0, 1.2, 0.2], [5.7, 4.4, 1.5, 0.4], [5.4, 3.9, 1.3, 0.4], [5.1, 3.5, 1.4, 0.3], [5.7, 3.8, 1.7, 0.3], [5.1, 3.8, 1.5, 0.3], [5.4, 3.4, 1.7, 0.2], [5.1, 3.7, 1.5, 0.4], [4.6, 3.6, 1.0, 0.2], [5.1, 3.3, 1.7, 0.5], [4.8, 3.4, 1.9, 0.2], [5.0, 3.0, 1.6, 0.2], [5.0, 3.4, 1.6, 0.4], [5.2, 3.5, 1.5, 0.2], [5.2, 3.4, 1.4, 0.2], [4.7, 3.2, 1.6, 0.2], [4.8, 3.1, 1.6, 0.2], [5.4, 3.4, 1.5, 0.4], [5.2, 4.1, 1.5, 0.1], [5.5, 4.2, 1.4, 0.2], [4.9, 3.1, 1.5, 0.2], [5.0, 3.2, 1.2, 0.2], [5.5, 3.5, 1.3, 0.2], [4.9, 3.6, 1.4, 0.1], [4.4, 3.0, 1.3, 0.2], [5.1, 3.4, 1.5, 0.2], [5.0, 3.5, 1.3, 0.3], [4.5, 2.3, 1.3, 0.3], [4.4, 3.2, 1.3, 0.2], [5.0, 3.5, 1.6, 0.6], [5.1, 3.8, 1.9, 0.4], [4.8, 3.0, 1.4, 0.3], [5.1, 3.8, 1.6, 0.2], [4.6, 3.2, 1.4, 0.2], [5.3, 3.7, 1.5, 0.2], [5.0, 3.3, 1.4, 0.2], [7.0, 3.2, 4.7, 1.4], [6.4, 3.2, 4.5, 1.5], [6.9, 3.1, 4.9, 1.5], [5.5, 2.3, 4.0, 1.3], [6.5, 2.8, 4.6, 1.5], [5.7, 2.8, 4.5, 1.3], [6.3, 3.3, 4.7, 1.6], [4.9, 2.4, 3.3, 1.0], [6.6, 2.9, 4.6, 1.3], [5.2, 2.7, 3.9, 1.4], [5.0, 2.0, 3.5, 1.0], [5.9, 3.0, 4.2, 1.5], [6.0, 2.2, 4.0, 1.0], [6.1, 2.9, 4.7, 1.4], [5.6, 2.9, 3.6, 1.3], [6.7, 3.1, 4.4, 1.4], [5.6, 3.0, 4.5, 1.5], [5.8, 2.7, 4.1, 1.0], [6.2, 2.2, 4.5, 1.5], [5.6, 2.5, 3.9, 1.1], [5.9, 3.2, 4.8, 1.8], [6.1, 2.8, 4.0, 1.3], [6.3, 2.5, 4.9, 1.5], [6.1, 2.8, 4.7, 1.2], [6.4, 2.9, 4.3, 1.3], [6.6, 3.0, 4.4, 1.4], [6.8, 2.8, 4.8, 1.4], [6.7, 3.0, 5.0, 1.7], [6.0, 2.9, 4.5, 1.5], [5.7, 2.6, 3.5, 1.0], [5.5, 2.4, 3.8, 1.1], [5.5, 2.4, 3.7, 1.0], [5.8, 2.7, 3.9, 1.2], [6.0, 2.7, 5.1, 1.6], [5.4, 3.0, 4.5, 1.5], [6.0, 3.4, 4.5, 1.6], [6.7, 3.1, 4.7, 1.5], [6.3, 2.3, 4.4, 1.3], [5.6, 3.0, 4.1, 1.3], [5.5, 2.5, 4.0, 1.3], [5.5, 2.6, 4.4, 1.2], [6.1, 3.0, 4.6, 1.4], [5.8, 2.6, 4.0, 1.2], [5.0, 2.3, 3.3, 1.0], [5.6, 2.7, 4.2, 1.3], [5.7, 3.0, 4.2, 1.2], [5.7, 2.9, 4.2, 1.3], [6.2, 2.9, 4.3, 1.3], [5.1, 2.5, 3.0, 1.1], [5.7, 2.8, 4.1, 1.3], [6.3, 3.3, 6.0, 2.5], [5.8, 2.7, 5.1, 1.9], [7.1, 3.0, 5.9, 2.1], [6.3, 2.9, 5.6, 1.8], [6.5, 3.0, 5.8, 2.2], [7.6, 3.0, 6.6, 2.1], [4.9, 2.5, 4.5, 1.7], [7.3, 2.9, 6.3, 1.8], [6.7, 2.5, 5.8, 1.8], [7.2, 3.6, 6.1, 2.5], [6.5, 3.2, 5.1, 2.0], [6.4, 2.7, 5.3, 1.9], [6.8, 3.0, 5.5, 2.1], [5.7, 2.5, 5.0, 2.0], [5.8, 2.8, 5.1, 2.4], [6.4, 3.2, 5.3, 2.3], [6.5, 3.0, 5.5, 1.8], [7.7, 3.8, 6.7, 2.2], [7.7, 2.6, 6.9, 2.3], [6.0, 2.2, 5.0, 1.5], [6.9, 3.2, 5.7, 2.3], [5.6, 2.8, 4.9, 2.0], [7.7, 2.8, 6.7, 2.0], [6.3, 2.7, 4.9, 1.8], [6.7, 3.3, 5.7, 2.1], [7.2, 3.2, 6.0, 1.8], [6.2, 2.8, 4.8, 1.8], [6.1, 3.0, 4.9, 1.8], [6.4, 2.8, 5.6, 2.1], [7.2, 3.0, 5.8, 1.6], [7.4, 2.8, 6.1, 1.9], [7.9, 3.8, 6.4, 2.0], [6.4, 2.8, 5.6, 2.2], [6.3, 2.8, 5.1, 1.5], [6.1, 2.6, 5.6, 1.4], [7.7, 3.0, 6.1, 2.3], [6.3, 3.4, 5.6, 2.4], [6.4, 3.1, 5.5, 1.8], [6.0, 3.0, 4.8, 1.8], [6.9, 3.1, 5.4, 2.1], [6.7, 3.1, 5.6, 2.4], [6.9, 3.1, 5.1, 2.3], [5.8, 2.7, 5.1, 1.9], [6.8, 3.2, 5.9, 2.3], [6.7, 3.3, 5.7, 2.5], [6.7, 3.0, 5.2, 2.3], [6.3, 2.5, 5.0, 1.9], [6.5, 3.0, 5.2, 2.0], [6.2, 3.4, 5.4, 2.3], [5.9, 3.0, 5.1, 1.8]], "data_target": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], "show_sample": "nodata"}},
) {
  stLog("debug", Key);
  async function checkD3Element(selector, timeout = 30000) {
    const interval = 100;
    const startTime = Date.now();

    const divElement = document.querySelector(selector);
    if (!divElement) {
      throw new Error(`Div with selector ${selector} does not exist.`);
    }

    while (Date.now() - startTime < timeout) {
      if (typeof d3 !== "undefined") {
        stLog("info", "D3.js successfully loaded");
        return true;
      }

      await new Promise((resolve) => setTimeout(resolve, interval));
    }

    stLog("warning", "D3.js not loaded after timeout");

    divElement.innerHTML = `
    <div style="color: red; font-weight: bold;">
      D3.js library is not loaded. Try Again :(.
    </div>`;

    return false;
  }
  checkD3Element("#graph-div-36082")
    .then(() => {
      const svgLine = `<svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-vector-spline"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M17 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" /><path d="M3 17m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" /><path d="M17 5c-6.627 0 -12 5.373 -12 12" /></svg>`

      const svgXAxis = `<svg style="display: inline" xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 13v.01" /><path d="M4 9v.01" /><path d="M4 5v.01" /><path d="M17 20l3 -3l-3 -3" /><path d="M4 17h16" /></svg>`;

      const svgYAxis = `<svg style="display: inline" xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M11 20h-.01" /><path d="M15 20h-.01" /><path d="M19 20h-.01" /><path d="M4 7l3 -3l3 3" /><path d="M7 20v-16" /></svg>`;

      const svgZoom = `<svg style="display: inline" xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg>`;

      const svgWindow = `<svg style="display: inline" xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 8v-2a2 2 0 0 1 2 -2h2" /><path d="M4 16v2a2 2 0 0 0 2 2h2" /><path d="M16 4h2a2 2 0 0 1 2 2v2" /><path d="M16 20h2a2 2 0 0 0 2 -2v-2" /></svg>`;

      const svgDownload = `<svg style="display: inline"  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" /><path d="M7 11l5 5l5 -5" /><path d="M12 4l0 12" /></svg>`;

      const svgSample = `<svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-test-pipe-2"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M15 3v15a3 3 0 0 1 -6 0v-15" /><path d="M9 12h6" /><path d="M8 3h8" /></svg>`

      var valid = false;
      function verifyKey() {
        try {
          const licenseKey = Key;

          const [encodedData, encodedSignature] = licenseKey.split(".");
          if (!encodedData || !encodedSignature) {
            throw new Error("Invalid license key format.");
          }

          let data, signature;
          try {
            data = nacl.util.decodeBase64(encodedData);
          } catch (e) {
            throw new Error("Bad key");
          }

          try {
            signature = nacl.util.decodeBase64(encodedSignature);
          } catch (e) {
            throw new Error("Bad key fromat: ");
          }

          const publicKeyHex =
            "6f0de3db182db3c08e4def6f8d49dab4d53fff2b02f8edc71cf7136f68ade82d";

          const publicKey = new Uint8Array(
            publicKeyHex.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)),
          );

          valid = false;
          try {
            valid = nacl.sign.detached.verify(data, signature, publicKey);
          } catch (e) {
            stLog("error", "Bad key:" + e);
          }

          var decodedData;
          try {
            decodedData = nacl.util.encodeUTF8(data);
          } catch (e) {
            throw new Error("Bad key");
          }
        } catch (e) {
          stLog("error", "Error in verifyKey function:", e);
        }

        function isFutureDate(inputString) {
          const dateRegex = /Date:\s*(\d{2}-\d{2}-\d{4})/;
          const match = inputString.match(dateRegex);

          if (match) {
            const dateString = match[1];

            const [day, month, year] = dateString.split("-").map(Number);

            const date = new Date(year, month - 1, day);

            const currentDate = new Date();

            return date > currentDate;
          } else {
            return false;
          }
        }
        if (valid) {
          valid = isFutureDate(decodedData);
        }
      }

      verifyKey();

      d3.select("#openModalBtn").attr("class", "st-option-button");
      d3.select("#graph-div-36082").attr("class", "st-body-tree-div-36082");

      let myid = Math.random();

      function addModalToFirstBody() {
        let firstBody = document.getElementsByTagName("body")[0];
        let modalHtml = `
    <div id="myModal-36082" class="st-modal">
        <div class="st-modal-content">
           <span id="closeBtn-36082" class="st-closeBtn">&times;</span>
            <div id="st-info-div-36082" class="st-info-div"></div>
            <div id = "toolbar-36082" class="st-toolbar"></div>
            <div id ="graph-div-36082" class ="st-tree-div-${myid}"></div>     
      <div id="st-side-panel-36082" class="st-side-panel">
            <span id="st-close-button-36082" class="st-close-button">&times;</span>
        <div>
        </div>
    </div>
    `;
        firstBody.insertAdjacentHTML("beforeend", modalHtml);
      }

      addModalToFirstBody();

      let Modalbutton = d3
        .select("#toolbar-36082")
        .append("button")
        .html(svgWindow)
        .attr("class", "st-option-button")
        .attr("id", "openModalBtn-36082");

      let modal = document.getElementById("myModal-36082");
      let btn = document.getElementById("openModalBtn-36082");
      let span = document.getElementById("closeBtn-36082");

      var lastDropdowDepthValue = 6
      const regr = "regression";
      const classification = "classification";
      const nodata = "nodata";
      let boldLinks = true;
      let globalX = true;
      let globalY = true;
      const yMultiplayer = 1;
      const xMultiplayer = 1;
      let isLocked = false;
      let globalMaxSample = 0;
      const pieHeight = 100;
      const pieWidth = 100;
      const histogramWidth = 150;
      const histogramHeight = 80;
      const scatterplotWidth = histogramWidth;
      const scatterplotHeight = histogramHeight;
      const scatterplotLeafWidth = histogramHeight + 10;
      const scatterplotLeafHeight = histogramHeight;
      const rectHeight = 110;
      const rectWidth = 195;

      const allColors = [
        "#FEFEBB",
        "#c7e9b4",
        "#41b6c4",
        "#FEFECD",
        "#CFE2D4",
        "#4575B4",
        "#313695",
        "#FEE090",
        "#006400",
        "#A6BDDB",
        "#444443",
        "#FFFF00",
        "#00FF00",
        "#0000FF",
        "#FFA500",
        "#800080",
        "#FF00FF",
        "#00FFFF",
        "#FFC0CB",
        "#808080",
        "#800000",
        "#008000",
        "#000080",
        "#FFFFE0",
        "#00FA9A",
        "#ADD8E6",
        "#FF4500",
        "#EE82EE",
        "#20B2AA",
        "#778899",
        "#B22222",
        "#7FFF00",
        "#4682B4",
        "#DAA520",
        "#4B0082",
        "#D2691E",
        "#5F9EA0",
        "#FF1493",
        "#696969",
        "#DC143C",
        "#00CED1",
        "#FFD700",
        "#9932CC",
        "#8B4513",
        "#00BFFF",
        "#FF69B4",
        "#A9A9A9",
        "#B22222",
        "#32CD32",
        "#1E90FF",
        "#FF8C00",
        "#BA55D3",
        "#8B0000",
        "#48D1CC",
        "#DDA0DD",
        "#FF6347",
        "#2E8B57",
        "#6495ED",
        "#FFA07A",
        "#9370DB",
        "#8B008B",
        "#839d9a",
        "#bfd2bf",
        "#a37774",
        "#124559",
        "#c0c5c1",
        "#46351d",
        "#7d8491",
        "#01161e",
        "#f1fffa",
        "#eff6e0",
        "#d5c7bc",
        "#93b7be",
        "#785964",
        "#646f4b",
        "#598392",
        "#eaf0ce",
        "#bbbe64",
        "#454545",
        "#443850",
        "#aec3b0",
        "#4b444c",
        "#9196a0",
        "#79625d",
        "#fba64c",
        "#38353e",
        "#a46848",
        "#453e2a",
        "#c8b496",
        "#2e1515",
        "#be9668",
        "#541e13",
        "#715a3b",
        "#403f4a",
        "#17090c",
        "#60606a",
        "#dcd1b8",
        "#3f2926",
        "#d03c32",
        "#9e8676",
        "#aeb0b2",
        "#d75841",
        "#e3aa71",
        "#de5d70",
        "#544540",
        "#335f9e",
        "#ab9682",
        "#150a2b",
        "#171559",
        "#d6d169",
        "#450c3d",
        "#913362",
        "#2b7873",
        "#2b9e62",
        "#65aacf",
        "#1f1718",
        "#67d95f",
        "#a61e49",
        "#f2c6b8",
        "#e6e3d8",
        "#eb9494",
        "#794d81",
        "#ffd8a9",
        "#ff5b4f",
        "#4a3778",
        "#ffb366",
        "#ad82cf",
        "#7e9770",
        "#f39d91",
        "#a9548a",
        "#d38e84",
        "#8455a9",
        "#814d6e",
        "#5d7668",
        "#f2af92",
        "#533a44",
        "#ffffe1",
        "#9e2081",
        "#235a63",
        "#c92e70",
        "#c37289",
        "#a83a94",
        "#db5989",
        "#4c55ba",
        "#77c1eb",
        "#f68484",
        "#acfff1",
        "#ffce96",
        "#512b8c",
        "#1f4572",
        "#221330",
        "#422452",
        "#d4ffb0",
        "#50cc9a",
        "#74ff86",
        "#201a47",
        "#2c8a9a",
        "#000000",
        "#782b8c",
        "#fffab2",
        "#fdffef",
        "#094d18",
        "#449481",
        "#f0cc69",
        "#df5f36",
        "#555555",
        "#497a3a",
        "#beb866",
        "#819650",
        "#7294d6",
        "#5b2b7c",
        "#ffffff",
        "#aaaaaa",
        "#000000",
        "#8cdaff",
        "#f0a34a",
        "#9f1d2e",
        "#5b59b3",
        "#4b0f37",
        "#63b9bb",
        "#227944",
      ];
      const colorSize = 20;


      var tooltipModal = d3
        .selectAll("#myModal-36082")
        .append("div")
        .attr("class", "st-tooltip")
        .style("position", "absolute")
        .style("opacity", 0);

      var tooltipBody = d3
        .selectAll("body")
        .append("div")
        .attr("class", "st-tooltip")
        .style("position", "absolute")
        .style("opacity", 0)
        .style("user-select", "none")
        .style("-webkit-user-select", "none")
        .style("-moz-user-select", "none")
        .style("-ms-user-select", "none");

      async function loadJSONFiles() {
        try {
          let data;

          if (pytree != {"node_data": {"feature": 3, "threshold": 0.8, "impurity": 0.667, "samples": 150, "class_distribution": [[50.0, 50.0, 50.0]], "treeclass": "setosa", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 50, "class_distribution": [[50.0, 0.0, 0.0]], "treeclass": "setosa", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], [0.8, "notexist"]], "left_node": null, "right_node": null}, "right_node": {"feature": 3, "threshold": 1.75, "impurity": 0.5, "samples": 100, "class_distribution": [[0.0, 50.0, 50.0]], "treeclass": "versicolor", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 0.8]], "left_node": {"feature": 2, "threshold": 4.95, "impurity": 0.168, "samples": 54, "class_distribution": [[0.0, 49.0, 5.0]], "treeclass": "versicolor", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], [1.75, 0.8]], "left_node": {"feature": 3, "threshold": 1.65, "impurity": 0.041, "samples": 48, "class_distribution": [[0.0, 47.0, 1.0]], "treeclass": "versicolor", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [4.95, "notexist"], [1.75, 0.8]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 47, "class_distribution": [[0.0, 47.0, 0.0]], "treeclass": "versicolor", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [4.95, "notexist"], [1.65, 0.8]], "left_node": null, "right_node": null}, "right_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 1, "class_distribution": [[0.0, 0.0, 1.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [4.95, "notexist"], [1.75, 1.65]], "left_node": null, "right_node": null}}, "right_node": {"feature": 3, "threshold": 1.55, "impurity": 0.444, "samples": 6, "class_distribution": [[0.0, 2.0, 4.0]], "treeclass": "virginica", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 4.95], [1.75, 0.8]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 3, "class_distribution": [[0.0, 0.0, 3.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 4.95], [1.55, 0.8]], "left_node": null, "right_node": null}, "right_node": {"feature": 2, "threshold": 5.45, "impurity": 0.444, "samples": 3, "class_distribution": [[0.0, 2.0, 1.0]], "treeclass": "versicolor", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 4.95], [1.75, 1.55]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 2, "class_distribution": [[0.0, 2.0, 0.0]], "treeclass": "versicolor", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [5.45, 4.95], [1.75, 1.55]], "left_node": null, "right_node": null}, "right_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 1, "class_distribution": [[0.0, 0.0, 1.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 5.45], [1.75, 1.55]], "left_node": null, "right_node": null}}}}, "right_node": {"feature": 2, "threshold": 4.85, "impurity": 0.043, "samples": 46, "class_distribution": [[0.0, 1.0, 45.0]], "treeclass": "virginica", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 1.75]], "left_node": {"feature": 0, "threshold": 5.95, "impurity": 0.444, "samples": 3, "class_distribution": [[0.0, 1.0, 2.0]], "treeclass": "virginica", "is_leaf": false, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], [4.85, "notexist"], ["notexist", 1.75]], "left_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 1, "class_distribution": [[0.0, 1.0, 0.0]], "treeclass": "versicolor", "is_leaf": true, "start_end_x_axis": [[5.95, "notexist"], ["notexist", "notexist"], [4.85, "notexist"], ["notexist", 1.75]], "left_node": null, "right_node": null}, "right_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 2, "class_distribution": [[0.0, 0.0, 2.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", 5.95], ["notexist", "notexist"], [4.85, "notexist"], ["notexist", 1.75]], "left_node": null, "right_node": null}}, "right_node": {"feature": -2, "threshold": -2.0, "impurity": 0.0, "samples": 43, "class_distribution": [[0.0, 0.0, 43.0]], "treeclass": "virginica", "is_leaf": true, "start_end_x_axis": [["notexist", "notexist"], ["notexist", "notexist"], ["notexist", 4.85], ["notexist", 1.75]], "left_node": null, "right_node": null}}}}, "tree_data": {"tree_type": "classification", "feature_names": ["sepal length (cm)", "sepal width (cm)", "petal length (cm)", "petal width (cm)"], "target_names": ["setosa", "versicolor", "virginica"], "data_feature": [[5.1, 3.5, 1.4, 0.2], [4.9, 3.0, 1.4, 0.2], [4.7, 3.2, 1.3, 0.2], [4.6, 3.1, 1.5, 0.2], [5.0, 3.6, 1.4, 0.2], [5.4, 3.9, 1.7, 0.4], [4.6, 3.4, 1.4, 0.3], [5.0, 3.4, 1.5, 0.2], [4.4, 2.9, 1.4, 0.2], [4.9, 3.1, 1.5, 0.1], [5.4, 3.7, 1.5, 0.2], [4.8, 3.4, 1.6, 0.2], [4.8, 3.0, 1.4, 0.1], [4.3, 3.0, 1.1, 0.1], [5.8, 4.0, 1.2, 0.2], [5.7, 4.4, 1.5, 0.4], [5.4, 3.9, 1.3, 0.4], [5.1, 3.5, 1.4, 0.3], [5.7, 3.8, 1.7, 0.3], [5.1, 3.8, 1.5, 0.3], [5.4, 3.4, 1.7, 0.2], [5.1, 3.7, 1.5, 0.4], [4.6, 3.6, 1.0, 0.2], [5.1, 3.3, 1.7, 0.5], [4.8, 3.4, 1.9, 0.2], [5.0, 3.0, 1.6, 0.2], [5.0, 3.4, 1.6, 0.4], [5.2, 3.5, 1.5, 0.2], [5.2, 3.4, 1.4, 0.2], [4.7, 3.2, 1.6, 0.2], [4.8, 3.1, 1.6, 0.2], [5.4, 3.4, 1.5, 0.4], [5.2, 4.1, 1.5, 0.1], [5.5, 4.2, 1.4, 0.2], [4.9, 3.1, 1.5, 0.2], [5.0, 3.2, 1.2, 0.2], [5.5, 3.5, 1.3, 0.2], [4.9, 3.6, 1.4, 0.1], [4.4, 3.0, 1.3, 0.2], [5.1, 3.4, 1.5, 0.2], [5.0, 3.5, 1.3, 0.3], [4.5, 2.3, 1.3, 0.3], [4.4, 3.2, 1.3, 0.2], [5.0, 3.5, 1.6, 0.6], [5.1, 3.8, 1.9, 0.4], [4.8, 3.0, 1.4, 0.3], [5.1, 3.8, 1.6, 0.2], [4.6, 3.2, 1.4, 0.2], [5.3, 3.7, 1.5, 0.2], [5.0, 3.3, 1.4, 0.2], [7.0, 3.2, 4.7, 1.4], [6.4, 3.2, 4.5, 1.5], [6.9, 3.1, 4.9, 1.5], [5.5, 2.3, 4.0, 1.3], [6.5, 2.8, 4.6, 1.5], [5.7, 2.8, 4.5, 1.3], [6.3, 3.3, 4.7, 1.6], [4.9, 2.4, 3.3, 1.0], [6.6, 2.9, 4.6, 1.3], [5.2, 2.7, 3.9, 1.4], [5.0, 2.0, 3.5, 1.0], [5.9, 3.0, 4.2, 1.5], [6.0, 2.2, 4.0, 1.0], [6.1, 2.9, 4.7, 1.4], [5.6, 2.9, 3.6, 1.3], [6.7, 3.1, 4.4, 1.4], [5.6, 3.0, 4.5, 1.5], [5.8, 2.7, 4.1, 1.0], [6.2, 2.2, 4.5, 1.5], [5.6, 2.5, 3.9, 1.1], [5.9, 3.2, 4.8, 1.8], [6.1, 2.8, 4.0, 1.3], [6.3, 2.5, 4.9, 1.5], [6.1, 2.8, 4.7, 1.2], [6.4, 2.9, 4.3, 1.3], [6.6, 3.0, 4.4, 1.4], [6.8, 2.8, 4.8, 1.4], [6.7, 3.0, 5.0, 1.7], [6.0, 2.9, 4.5, 1.5], [5.7, 2.6, 3.5, 1.0], [5.5, 2.4, 3.8, 1.1], [5.5, 2.4, 3.7, 1.0], [5.8, 2.7, 3.9, 1.2], [6.0, 2.7, 5.1, 1.6], [5.4, 3.0, 4.5, 1.5], [6.0, 3.4, 4.5, 1.6], [6.7, 3.1, 4.7, 1.5], [6.3, 2.3, 4.4, 1.3], [5.6, 3.0, 4.1, 1.3], [5.5, 2.5, 4.0, 1.3], [5.5, 2.6, 4.4, 1.2], [6.1, 3.0, 4.6, 1.4], [5.8, 2.6, 4.0, 1.2], [5.0, 2.3, 3.3, 1.0], [5.6, 2.7, 4.2, 1.3], [5.7, 3.0, 4.2, 1.2], [5.7, 2.9, 4.2, 1.3], [6.2, 2.9, 4.3, 1.3], [5.1, 2.5, 3.0, 1.1], [5.7, 2.8, 4.1, 1.3], [6.3, 3.3, 6.0, 2.5], [5.8, 2.7, 5.1, 1.9], [7.1, 3.0, 5.9, 2.1], [6.3, 2.9, 5.6, 1.8], [6.5, 3.0, 5.8, 2.2], [7.6, 3.0, 6.6, 2.1], [4.9, 2.5, 4.5, 1.7], [7.3, 2.9, 6.3, 1.8], [6.7, 2.5, 5.8, 1.8], [7.2, 3.6, 6.1, 2.5], [6.5, 3.2, 5.1, 2.0], [6.4, 2.7, 5.3, 1.9], [6.8, 3.0, 5.5, 2.1], [5.7, 2.5, 5.0, 2.0], [5.8, 2.8, 5.1, 2.4], [6.4, 3.2, 5.3, 2.3], [6.5, 3.0, 5.5, 1.8], [7.7, 3.8, 6.7, 2.2], [7.7, 2.6, 6.9, 2.3], [6.0, 2.2, 5.0, 1.5], [6.9, 3.2, 5.7, 2.3], [5.6, 2.8, 4.9, 2.0], [7.7, 2.8, 6.7, 2.0], [6.3, 2.7, 4.9, 1.8], [6.7, 3.3, 5.7, 2.1], [7.2, 3.2, 6.0, 1.8], [6.2, 2.8, 4.8, 1.8], [6.1, 3.0, 4.9, 1.8], [6.4, 2.8, 5.6, 2.1], [7.2, 3.0, 5.8, 1.6], [7.4, 2.8, 6.1, 1.9], [7.9, 3.8, 6.4, 2.0], [6.4, 2.8, 5.6, 2.2], [6.3, 2.8, 5.1, 1.5], [6.1, 2.6, 5.6, 1.4], [7.7, 3.0, 6.1, 2.3], [6.3, 3.4, 5.6, 2.4], [6.4, 3.1, 5.5, 1.8], [6.0, 3.0, 4.8, 1.8], [6.9, 3.1, 5.4, 2.1], [6.7, 3.1, 5.6, 2.4], [6.9, 3.1, 5.1, 2.3], [5.8, 2.7, 5.1, 1.9], [6.8, 3.2, 5.9, 2.3], [6.7, 3.3, 5.7, 2.5], [6.7, 3.0, 5.2, 2.3], [6.3, 2.5, 5.0, 1.9], [6.5, 3.0, 5.2, 2.0], [6.2, 3.4, 5.4, 2.3], [5.9, 3.0, 5.1, 1.8]], "data_target": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], "show_sample": "nodata"}}) {
            var treeData = pytree;

            data = {
              nodeData: treeData.node_data,
              treeData: treeData.tree_data,
            };
          } else {
            const [treeDataResponse] = await Promise.all([fetch(pathJson)]);

            if (!treeDataResponse.ok) {
              throw new Error("Network response was not ok");
            }

            const treeData = await treeDataResponse.json();
            stLog("info", treeData);
            data = {
              nodeData: treeData.node_data,
              treeData: treeData.tree_data,
            };
          }
          return data;
        } catch (error) {
          stLog("error", "Error loading JSON files:");
        }
      }

      loadJSONFiles().then((data) => {
        if (data) {
          const { nodeData, treeData } = data;

          let nodeIdCounter = 0;

          function convertData(node) {
            node.id = nodeIdCounter++;
            if (node.is_leaf) {
              return { children: [], ...node };
            } else {
              return {
                children: [
                  convertData(node.left_node),
                  convertData(node.right_node),
                ],
                ...node,
              };
            }
          }

          let treeDataConverted = convertData(nodeData);


          let featureNumber = treeData.data_feature[0].length;
          var globalXExtent = Array.from({ length: featureNumber }, () => [
            Infinity,
            -Infinity,
          ]);
          var globalYExtent = Array.from({ length: featureNumber }, () => [
            0,
            -Infinity,
          ]);
          if(!valid){
            treeData.show_sample = "nodata"
          }

          function click(event, d) {
            if (isLocked) return;
            if (d.children == null && d._children == null) {
              return;
            }
            stLog("debug", " Collapse click event");
            isLocked = true;
            d3.selectAll("#st-depth-dropdown").attr("disabled", "disabled");

            if (d.children) {
              d._children = d.children;
              d.children = null;
            } else {
              d.children = d._children;
              d._children = null;
            }
            update(d, false);
            setTimeout(() => {
              isLocked = false;
              d3.selectAll("#st-depth-dropdown").attr("disabled", null);
            }, duration);
          }

          let nodeTreeMargin = { top: 20, right: 90, bottom: 160, left: 90 },
            treeWidth = 2500 - nodeTreeMargin.left - nodeTreeMargin.right,
            treeHeight = 1100 - nodeTreeMargin.top - nodeTreeMargin.bottom;

          var i = 0;
          const duration = 1250;


          let colors = allColors.slice(0, colorSize);

          if (treeData.feature_names.length > colors.length) {
            let missingColors = treeData.feature_names.length - colors.length;

            function getRandomColor() {
              let letters = '0123456789ABCDEF';
              let color = '#';
              for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
              }
              return color;
            }

            for (let i = 0; i < missingColors; i++) {
              colors.push(getRandomColor());
            }
          }

          var zoom = d3.zoom().scaleExtent([0.05, 5]).on("zoom", zoomed);

          function zoomed(event) {
            treeSVG.attr("transform", event.transform);
          }

          function isModalVisible() {
            var modal = document.getElementById("myModal-36082");
            return modal.style.display === "block";
          }

          span.onclick = function() {
            modal.style.display = "none";
            resetZoom();
          };

          window.onclick = function(event) {
            if (event.target == modal) {
              modal.style.display = "none";
              resetZoom();
            }
          };

          btn.onclick = function() {
            modal.style.display = "block";
            resetZoom();
          };

          function resetZoom() {
            if (isModalVisible()) {
              var divElement = document.getElementsByClassName(
                `st-tree-div-${myid}`,
              );
              var divWidth = divElement[0].clientWidth;
              var divHeight = divElement[0].clientHeight;
              svgElement = d3.select(divElement[0]).select("svg#mySVG-36082");
            } else {
              var divElement =
                document.getElementsByClassName("st-body-tree-div-36082");
              var divWidth = divElement[0].clientWidth;
              var divHeight = divElement[0].clientHeight;
              svgElement = d3.select(divElement[0]).select("svg#mySVG-36082");
            }
            let currentScale = 1;
            if (treeWidth < divWidth) {
              currentScale = 1;
            } else {
              currentScale = divWidth / treeWidth;
            }
            currentScale = Math.max(0.05, currentScale);
            let rootTransform = d3.zoomIdentity
              .translate(
                -treeRoot.x * currentScale + divWidth / 2,
                treeRoot.y * currentScale + divHeight / 15,
              )
              .scale(currentScale);

            svgElement
              .transition()
              .duration(duration)
              .call(zoom.transform, rootTransform);
          }

          var treeRoot = d3.hierarchy(treeDataConverted);
          treeRoot.x0 = 0;
          treeRoot.y0 = treeWidth / 2;

          var maxDepthVertical = 0;
          var maxLeafs = 0;

          function maxSize(d) {
            maxDepthVertical = Math.max(maxDepthVertical, d.depth);
            if (d.children) {
              d.children.forEach(function(dc) {
                maxSize(dc);
              });
            } else {
              maxLeafs++;
            }
          }
          maxSize(treeRoot);

          treeWidth = maxLeafs * 300;
          treeHeight = maxDepthVertical * 400;

          var treeSVG = d3
            .selectAll("#graph-div-36082")
            .append("svg")
            .attr(
              "width",
              treeWidth + nodeTreeMargin.right + nodeTreeMargin.left,
            )
            .attr(
              "height",
              treeHeight + nodeTreeMargin.top + nodeTreeMargin.bottom,
            )
            .attr("id", "mySVG-36082")
            .attr("class", "st-svg")
            .call(zoom)
            .append("g")
            .attr(
              "transform",
              "translate(" +
              nodeTreeMargin.left +
              "," +
              nodeTreeMargin.top +
              ")",
            );

          var sideSVG = d3.selectAll("#st-side-panel-36082").append("svg")
            .attr("id", "st-side-svg-36082")
            .attr("class", "st-svg-2")
            .attr("width", "100%")
            .attr("height", 1000)
            .style("background-color", "#f3f9fb");



          var startDepth = 6

          if (typeof startDepth == "string") {
            startDepth = 4;
            stLog("debug", "aha lol xd")
          }

          stLog("debug", startDepth, "start depth value");

          collapse(treeRoot, 0, startDepth);
          update(treeRoot, false);
          resetZoom();

          function update(source, resetTree) {
          var maxDepthReset =0;
            if (resetTree) {

              function DFS(node,depth,maxDepth) {
                depth++;
                if (node.children) {
                  node.children.forEach(function(child) {
                    maxDepthReset = Math.max(depth,maxDepthReset);
                    DFS(child,depth,maxDepth);
                  })
                }
              }
              DFS(treeRoot,0,maxDepthReset);

              treeSVG.selectAll(".treeNode").remove();
              treeSVG.selectAll(".st-link").remove();
              treeSVG.selectAll("g").remove();
              treeRoot = d3.hierarchy(treeDataConverted);
              collapse(treeRoot,0, maxDepthReset+1);
              stLog("debug", treeSVG, "treeSVG")
              i = 0;
            }
            d3.selectAll(".st-link").style("stroke", "black");
            maxSample = -Infinity;
            minSample = Infinity;

            maxLeafs = 0;

            function maxSize(d) {
              if (d.children) {
                d.children.forEach(function(dc) {
                  maxSize(dc);
                });
              } else {
                maxLeafs++;
              }
            }
            maxSize(treeRoot);

            treeWidth = maxLeafs * 300;
            treeHeight = maxDepthVertical * 400;

            let treeLayout = d3.tree().size([treeWidth, treeHeight]);
            let treeLayoutData = treeLayout(treeRoot);
            stLog("debug", treeLayoutData, "TreeLayout");

            let nodes = treeLayoutData.descendants(),
              links = treeLayoutData.descendants().slice(1);

            nodes.forEach(function(d) {
              d.y = d.depth * 180;
              if (!d.hasOwnProperty("cx")) {
                d.cx = d.x * xMultiplayer;
              }
              if (!d.hasOwnProperty("cy")) {
                d.cy = d.y * yMultiplayer;
              }
            });



            nodes.forEach(function(d) {
              stLog("debug", "AAAAAAAAAAAAAAA")
              d.y0 = d.y;
              d.x0 = d.x;
            });

            var treeNode = treeSVG
              .selectAll(".treeNode")
              .data(treeRoot.descendants(), function(d) {
                return d.id || (d.id = ++i);
              });
            stLog("debug", treeNode, "treeNode")

            function getDescendants(sourceRoot, myDescendants = []) {
              if (sourceRoot._children) {
                sourceRoot._children.forEach(function(d) {
                  myDescendants.push(d);
                  getDescendants(d, myDescendants);
                });
              }

              if (sourceRoot.children) {
                sourceRoot.children.forEach(function(d) {
                  myDescendants.push(d);
                  getDescendants(d, myDescendants);
                });
              }

              return myDescendants;
            }

            function getAscentors(sourceRoot, myAscentors = []) {
              if (sourceRoot.parent) {
                myAscentors.push(sourceRoot.parent);
                getDescendants(sourceRoot.parent, myAscentors);
              }

              return myAscentors;
            }

            let enterDescendants = getDescendants(source);

            let idsArrayDescendants = enterDescendants.map(function(d) {
              return d.id;
            });

            idsArrayDescendants.push(source.id);

            var treeNodeEnter = treeNode
              .enter()
              .append("g")
              .attr("class", "treeNode")
              .attr(
                "transform",
                (d) => "translate(" + source.cx + "," + source.cy + ")",
              )
              .on("click", click);

              globalXExtent = Array.from({ length: featureNumber }, () => [
                Infinity,
                -Infinity,
              ]);
              globalYExtent = Array.from({ length: featureNumber }, () => [
                0,
                -Infinity,
              ]);


            for (let i = 0; i < featureNumber; i++) {
              let tempArr = [];
              for (let j = 0; j < treeData.data_feature.length; j++) {
                tempArr.push(treeData.data_feature[j][i]);
              }
              let tempGlobalXExtent = d3.extent(tempArr);
              globalXExtent[i][0] = Math.min(
                globalXExtent[i][0],
                tempGlobalXExtent[0],
              );
              globalXExtent[i][1] = Math.max(
                globalXExtent[i][1],
                tempGlobalXExtent[1],
              );
            }

            for (let i = 0; i < featureNumber; i++) {
              globalXExtent[i][0] -= 0.2;
              globalXExtent[i][1] += 0.2;
            }

            if (treeData.tree_type == regr) {
              treeNodeEnter.each(function(d) {
                processRegressionNode.call(
                  this,
                  d,
                  treeData,
                  scatterplotWidth,
                  scatterplotHeight,
                  histogramWidth,
                  histogramHeight,
                  rectWidth,
                  rectHeight,
                  tooltipBody,
                  tooltipModal,
                  colors
                );
              });
              treeNodeEnter.each(function(d) {
                processRegressionLeaf.call(
                  this,                
                  d,                   
                  treeData,           
                  scatterplotLeafWidth,
                  scatterplotLeafHeight,
                  rectHeight,       
                  tooltipBody,         
                  tooltipModal,        
                  click,              
                  showpath             
                );
              });
            }

            if (treeData.tree_type == classification) {
              treeNodeEnter.each(function(d) {
                processClassificationNode.call(
                  this,
                  treeData,
                  tooltipBody,
                  tooltipModal,
                  globalX,
                  globalXExtent,
                  globalY,
                  globalYExtent,
                  click,
                  histogramWidth,
                  histogramHeight,
                  rectWidth,
                  rectHeight,
                  colors,
                  d
                );
              });

              treeNodeEnter.each(function(d) {
                if (d.data.is_leaf) {
                  var sum = 0;
                  for (
                    let i = 0;
                    i < d.data.class_distribution[0].length;
                    i++
                  ) {
                    sum = sum + parseFloat(d.data.class_distribution[0][i]);
                  }
                  maxSample = Math.max(maxSample, sum);
                  minSample = Math.min(minSample, sum);
                }
              });
              if (maxSample > 0) {
                globalMaxSample = maxSample;
              }

              treeNodeEnter.each(function(d) {
                processClassificationLeaf.call(
                  this,          
                  treeData,     
                  pieWidth,      
                  pieHeight,     
                  rectWidth,    
                  rectHeight,   
                  scatterplotWidth, 
                  scatterplotHeight, 
                  colors,        
                  maxSample,     
                  showpath,     
                  d3,            
                  tooltipBody,
                  tooltipModal,  
                  d             
                );
              });
            }
            if (treeData.tree_type.startsWith(nodata)) {
              treeNodeEnter.each(function(d) {
                if (!d.data.is_leaf) {
                  d3.select(this)
                    .append("rect")
                    .attr("class", "histogram-background")
                    .attr("x", -(scatterplotWidth / 2) - 25)
                    .attr("y", -10)
                    .attr("width", rectWidth)
                    .attr("height", rectHeight)
                    .attr("stroke-width", 1)
                    .attr("stroke", "#545454")
                    .attr("rx", 10)
                    .attr("ry", 10)
                    .style("fill", "#ffffff");

                  d3.select(this)
                    .append("text")
                    .attr("dy", ".0em")
                    .attr("y", 10)
                    .attr("class", "st-target")
                    .style("text-anchor", "middle")
                    .text((d) => "Threshold " + d.data.threshold)
                    .style("-webkit-user-select", "none")
                    .style("-moz-user-select", "none")
                    .style("-ms-user-select", "none");

                  d3.select(this)
                    .append("text")
                    .attr("dy", ".0em")
                    .attr("y", 30)
                    .attr("class", "st-target")
                    .style("text-anchor", "middle")
                    .text((d) => "Impurity: " + d.data.impurity)
                    .style("-webkit-user-select", "none")
                    .style("-moz-user-select", "none")
                    .style("-ms-user-select", "none");

                  d3.select(this)
                    .append("text")
                    .attr("dy", ".0em")
                    .attr("y", 50)
                    .attr("class", "st-target")
                    .style("text-anchor", "middle")
                    .text((d) => "Samples " + d.data.samples)
                    .style("-webkit-user-select", "none")
                    .style("-moz-user-select", "none")
                    .style("-ms-user-select", "none");

                  d3.select(this)
                    .append("text")
                    .attr("dy", ".0em")
                    .attr("y", 70)
                    .attr("class", "st-target")
                    .style("text-anchor", "middle")
                    .text((d) => "Value [" + d.data.class_distribution + "]")
                    .style("-webkit-user-select", "none")
                    .style("-moz-user-select", "none")
                    .style("-ms-user-select", "none");

                  d3.select(this)
                    .append("text")
                    .attr("dy", ".0em")
                    .attr("y", 90)
                    .attr("class", "st-target")
                    .style("text-anchor", "middle")
                    .text((d) => "Class " + d.data.treeclass)
                    .style("-webkit-user-select", "none")
                    .style("-moz-user-select", "none")
                    .style("-ms-user-select", "none");



                }
                if (d.data.is_leaf) {
                  d3.select(this)
                    .append("rect")
                    .attr("class", "histogram-background")
                    .attr("x", -(scatterplotWidth / 2) - 5)
                    .attr("y", -10)
                    .attr("width", rectWidth - 40)
                    .attr("height", rectHeight)
                    .attr("stroke-width", 1)
                    .attr("stroke", "#545454")
                    .attr("rx", 10)
                    .attr("ry", 10)
                    .style("fill", "#ffffff");


                  d3.select(this)
                    .append("text")
                    .attr("dy", ".0em")
                    .attr("y", 10)
                    .attr("class", "st-target")
                    .style("text-anchor", "middle")
                    .text((d) => "Samples " + d.data.samples)
                    .style("-webkit-user-select", "none")
                    .style("-moz-user-select", "none")
                    .style("-ms-user-select", "none");


                  d3.select(this)
                    .append("text")
                    .attr("dy", ".0em")
                    .attr("y", 40)
                    .attr("class", "st-target")
                    .style("text-anchor", "middle")
                    .text((d) => "Value [" + d.data.class_distribution + "]")
                    .style("-webkit-user-select", "none")
                    .style("-moz-user-select", "none")
                    .style("-ms-user-select", "none");


                  d3.select(this)
                    .append("text")
                    .attr("dy", ".0em")
                    .attr("y", 70)
                    .attr("class", "st-target")
                    .style("text-anchor", "middle")
                    .text((d) => "Class " + d.data.treeclass)
                    .style("-webkit-user-select", "none")
                    .style("-moz-user-select", "none")
                    .style("-ms-user-select", "none");



                }
              });


            }

            var treeNodeUpdate = treeNodeEnter.merge(treeNode);

            treeNodeUpdate
              .transition()
              .duration(duration)
              .tween("logging", function(d) {
                let interpolateX = d3.interpolate(
                  source.x0 * xMultiplayer,
                  d.x * xMultiplayer,
                );
                let interpolateY = d3.interpolate(
                  source.y * yMultiplayer,
                  d.y * yMultiplayer,
                );

                return function(t) {
                  let x = interpolateX(t);
                  let y = interpolateY(t);
                  d.cx = x;
                  d.cy = y;
                };
              })
              .attr("transform", function(d) {
                return (
                  "translate(" +
                  d.x * xMultiplayer +
                  "," +
                  d.y * yMultiplayer +
                  ")"
                );
              });

            let exitDescendants = [];

            exitDescendants = getDescendants(source);

            let descendantIds = new Set(exitDescendants.map((d) => d.id));

            let treeNodeExit = treeNode
              .exit()
              .filter(function(d) {
                return descendantIds.has(d.id);
              })
              .transition()
              .duration(duration)
              .attr("transform", function(d) {
                return (
                  "translate(" +
                  (source.x + rectWidth / 2) +
                  "," +
                  (source.y0 + rectHeight / 2) +
                  ")"
                );
              })
              .attr("font-size", "1em")
              .remove();

            treeNodeExit
              .selectAll(".st-target")
              .style("fill-opacity", 1e-6)
              .style("font-size", "0px")
              .attr("x", -rectWidth / 2)
              .attr("y", 0);

                treeNodeExit
                .selectAll(".st-triangle")
                .style("stroke-width", 0)
                .style("fill-opacity",0)
                .attr("transform", function(d) {
                  return "translate(" + (-source.x/6) + "," + (-source.y0/6 ) + ")";
                })
                .size(0);

            const smallScaleX = d3.scaleLinear().domain(0, 10).range([0, 1]);
            const smallScaleY = d3.scaleLinear().domain(10, 0).range([1, 0]);

            treeNodeExit
              .selectAll(".xAxis")
              .attr("transform", "translate(" + -rectWidth / 2 + "," + 0 + ")")
              .call(
                d3
                  .axisBottom(smallScaleX)
                  .tickSize(0)
                  .tickPadding(8)
                  .ticks(2)
                  .tickFormat(d3.format(",.1f")),
              );

            treeNodeExit
              .selectAll(".yAxis")
              .attr("transform", "translate(" + -rectWidth / 2 + "," + 0 + ")")
              .call(
                d3
                  .axisLeft(smallScaleY)
                  .tickSize(0)
                  .tickPadding(8)
                  .ticks(2)
                  .tickFormat(d3.format(",.1f")),
              );

            treeNodeExit
              .selectAll("rect.histogram-background")
              .attr("width", 1e-6)
              .attr("height", 1e-6)
              .attr("x", -rectWidth / 2)
              .attr("y", 0);

            treeNodeExit
              .selectAll("rect.bar")
              .attr("width", 1e-6)
              .attr("height", 1e-6)
              .attr("x", -histogramWidth / 2 + 70)
              .attr("y", 0);

            treeNodeExit
              .selectAll("circle")
              .attr("r", 1e-6)
              .attr("cx", -scatterplotWidth / 2 + 20)
              .attr("cy", 0);

            treeNodeExit
              .selectAll("path.piechart")
              .attr("transform", "translate(" + -rectWidth / 2 + "," + 0 + ")")
              .attr("d", d3.arc().innerRadius(0).outerRadius(1));
            let gridAnimation = treeNodeExit.select(".st-grid");

            treeNodeExit
              .selectAll("line.threshold-line")
              .attr("transform", "translate(" + -rectWidth + "," + -40 + ")")
              .attr("x1", rectWidth / 2)
              .attr("x2", rectWidth / 2)
              .attr("y1", rectHeight / 2 - 15)
              .attr("y2", rectHeight / 2)
              .attr("stroke-width", 0);

            treeNodeExit
              .selectAll("line.average-line")
              .attr("transform", "translate(" + -rectWidth + "," + -40 + ")")
              .attr("x1", rectWidth / 2)
              .attr("x2", rectWidth / 2)
              .attr("y1", rectHeight / 2 - 15)
              .attr("y2", rectHeight / 2 - 15)
              .attr("stroke-width", 0);

            gridAnimation.selectAll("line").attr("x2", 0).attr("y2", 0);

            treeNodeExit
              .selectAll(".yAxis-text")
              .attr("transform", "translate(" + 0 + "," + -40 + ")")
              .style("fill-opacity", 1e-6)
              .style("font-size", "0px")
              .attr("x", 0);

            treeNodeExit
              .selectAll(".xAxis-text")
              .attr("transform", "translate(" + 0 + "," + -40 + ")")
              .style("fill-opacity", 1e-6)
              .style("font-size", "0px");

            treeNodeExit
              .selectAll(".st-pie-target")
              .attr("y", function(d, i) {
                const radius = Math.max(
                  20,
                  (Math.min(pieWidth, pieHeight) / 2) *
                  Math.sqrt(d.data.classDistributionValue / globalMaxSample),
                );

                return -10 - radius * 2 - i * 40;
              })
              .attr("transform", "translate(" + -rectWidth / 2 + "," + 0 + ")")
              .style("fill-opacity", 1e-6)
              .style("font-size", "0px");

            treeNodeExit
              .selectAll(".st-pie-target2")
              .attr("y", function(d, i) {
                const radius = Math.max(
                  20,
                  (Math.min(pieWidth, pieHeight) / 2) *
                  Math.sqrt(d.data.classDistributionValue / globalMaxSample),
                );

                return -10 - radius * 2 - i * 40;
              })
              .attr("transform", "translate(" + -rectWidth / 2 + "," + 0 + ")")
              .style("fill-opacity", 1e-6)
              .style("font-size", "0px");

            let link = treeSVG.selectAll("path.st-link").data(links, function(d) {
              return d.id;
            });

            const mouseover = function(d) {

              const currentStroke = d3.select(this).style("stroke");

              tooltipBody.style("opacity", 1);
              tooltipModal.style("opacity", 1);

              if (currentStroke !== "red") {
                d3.select(this).style("stroke", "#EF4A60");
              }
            };

            const mouseleave = function(d) {

              const currentStroke = d3.select(this).style("stroke");

              tooltipBody
                .style("opacity", 0)
                .style("top", 0 + "px")
                .style("left", 0 + "px");

              tooltipModal
                .style("opacity", 0)
                .style("top", 0 + "px")
                .style("left", 0 + "px");

              if (currentStroke !== "red") {
                d3.select(this).style("stroke", "black");
              }
            };

            const mousemove = function(event, d) {
              if (treeData.tree_type == classification) {
                var currentDistribution = 0;
                for (let i = 0; i < d.data.class_distribution[0].length; i++) {
                  currentDistribution =
                    currentDistribution +
                    parseInt(d.data.class_distribution[0][i]);
                }

                tooltipModal
                  .html(
                    `<b>Class distribution in link:</b>: ${currentDistribution}`,
                  )
                  .style("top", event.pageY - 10 + "px")
                  .style("left", event.pageX + 10 + "px");

                tooltipBody
                  .html(
                    `<b>Class distribution in link:</b>: ${currentDistribution}`,
                  )
                  .style("top", event.pageY - 10 + "px")
                  .style("left", event.pageX + 10 + "px");
              }
              if (treeData.tree_type == regr) {
                var currentDistribution = d.data.samples;

                tooltipModal
                  .html(`<b>Samples in link:</b>: ${currentDistribution}`)
                  .style("top", event.pageY - 10 + "px")
                  .style("left", event.pageX + 10 + "px");

                tooltipBody
                  .html(`<b>Samples in link:</b>: ${currentDistribution}`)
                  .style("top", event.pageY - 10 + "px")
                  .style("left", event.pageX + 10 + "px");
              }
            };

            var linkEnter = link
              .enter()
              .insert("path", "g")
              .attr("class", "st-link")
              .attr("d", function(d) {
                var o = { x: source.cx, y: source.cy };
                return diagonal(o, o);
              })
              .style("fill", "none")
              .style("stroke-width", "2px")
              .on("mouseover", mouseover)
              .on("mouseleave", mouseleave)
              .on("mousemove", mousemove);

            var allSamples = 0;
            var allSamplesRegr = 0;
            if (treeData.tree_type == regr) {
              allSamplesRegr = nodeData.samples;
            }
            for (let i = 0; i < nodeData.class_distribution[0].length; i++) {
              allSamples =
                allSamples + parseInt(nodeData.class_distribution[0][i]);
            }
            if (boldLinks == true) {
              if (treeData.tree_type == classification) {
                linkEnter.each(function(d) {
                  var currentDistribution = 0;
                  for (
                    let i = 0;
                    i < d.data.class_distribution[0].length;
                    i++
                  ) {
                    currentDistribution =
                      currentDistribution +
                      parseInt(d.data.class_distribution[0][i]);
                  }
                  d3.select(this).style(
                    "stroke-width",
                    Math.max(20 * (currentDistribution / allSamples), 1),
                  );
                });
              }
              if (treeData.tree_type == regr) {
                linkEnter.each(function(d) {
                  var currentDistribution = 0;
                  currentSamples = d.data.samples;
                  d3.select(this).style(
                    "stroke-width",
                    Math.max(20 * (currentSamples / allSamplesRegr), 1),
                  );
                });
              }
            }

            var linkUpdate = linkEnter.merge(link);

            linkUpdate
              .transition()
              .duration(duration)
              .attr("d", function(d) {
                return diagonal(d.parent, d);
              });

            var linkExit = link
              .exit()
              .filter(function(d) {
                return descendantIds.has(d.id);
              })
              .transition()
              .duration(duration)
              .attr("d", function(d) {
                var o = { x: source.x, y: source.y0 };
                return diagonal(o, o);
              })
              .remove();


            function diagonal(s, d) {
              path = `M ${s.x * xMultiplayer} ${s.y * yMultiplayer}
            C ${(s.x * xMultiplayer + d.x * xMultiplayer) / 2} ${s.y * yMultiplayer},
              ${(s.x * xMultiplayer + d.x * xMultiplayer) / 2} ${d.y * yMultiplayer},
              ${d.x * xMultiplayer} ${d.y * yMultiplayer}`;

              return path;
            }

          }
          if (!valid) {
            d3.selectAll("#st-info-div-36082")
              .append("p")
              .text("Free for non-commercial use and evaluation")
              .style("font-size", "12px")
              .style("color", "black");
          }
          const mouseover = function(d) {
            tooltipBody.style("opacity", 1);
            tooltipModal.style("opacity", 1);
          };

          const mouseleave = function(d) {
            tooltipBody
              .style("opacity", 0)
              .style("top", 0 + "px")
              .style("left", 0 + "px");
            tooltipModal
              .style("opacity", 0)
              .style("top", 0 + "px")
              .style("left", 0 + "px");
          };

          const mousemoveButton = function(event, d) {
            stLog("info", d);
            tooltipBody
              .html(`<b>${d}</b>`)
              .style("top", event.pageY - 10 + "px")
              .style("left", event.pageX + 10 + "px");

            tooltipModal
              .html(`<b>${d}</b>`)
              .style("top", event.pageY - 10 + "px")
              .style("left", event.pageX + 10 + "px");
          };

          d3.select("#openModalBtn-36082")
            .on("mouseover", mouseover)
            .on("mouseleave", mouseleave)
            .on("mousemove", function(d) {
              mousemoveButton(event, "Open modal window");
            });

          if (valid) {
            var saveSvgbutton = d3
              .selectAll("#toolbar-36082")
              .append("button")
              .html(svgDownload)
              .attr("id", "svgButton")
              .attr("class", "st-option-button")
              .on("click", saveSvg)
              .on("mouseover", mouseover)
              .on("mouseleave", mouseleave)
              .on("mousemove", function(d) {
                mousemoveButton(event, "Save SVG");
              });
          }


          if (treeData.show_sample != "nodata" && valid && !treeData.tree_type.startsWith("nodata") ) {
            var showSampleButton = d3
              .selectAll("#toolbar-36082")
              .append("button")
              .html(svgSample)
              .attr("id", "showSampleButton")
              .attr("class", "st-option-button")
              .on("click", showSample)
              .on("mouseover", mouseover)
              .on("mouseleave", mouseleave)
              .on("mousemove", function(d) {
                mousemoveButton(event, "Show sample path");
              });
          }

          function showSample() {
            stLog("debug", treeRoot, "root");
            var sampleNode = null;
            showSampleDFS(treeRoot);
            function showSampleDFS(node) {
              if (node.children) {
                node.children.forEach(function(child) {
                  showSampleDFS(child)
                })
              }
              else if (node._children) {
                node._children.forEach(function(child) {
                  showSampleDFS(child)
                })
              }
              else {
                stLog("debug", node, "Cojest")
                var isSampleExistInThisNode = true;
                node.data.start_end_x_axis.forEach((currentElement, i) => {
                  const sampleValue = treeData.show_sample[i];

                  if (currentElement[0] != "notexist" && sampleValue > currentElement[0]) {
                    isSampleExistInThisNode = false;
                  }

                  if (currentElement[1] != "notexist" && sampleValue < currentElement[1]) {
                    isSampleExistInThisNode = false;
                  }
                });
                if (isSampleExistInThisNode) {
                  sampleNode = node;
                }
              }
            }
            stLog("debug", sampleNode, "SampleNode");
            if (isLocked) {
              return
            };
            isLocked = true;
            d3.selectAll("#st-depth-dropdown").attr("disabled", "disabled");
            showDepth(treeRoot, 0, sampleNode.depth + 1, true);
            uArr.forEach(function(d) {
              update(d, false);
            });
            dropdownDepth.property("value", optionsDepth[sampleNode.depth]);
            setTimeout(() => {
              isLocked = false;
              d3.selectAll("#st-depth-dropdown").attr("disabled", null);
            }, duration);
            uArr = [];
            resetZoom();
            showpath(sampleNode);


          }

          function showpath(d) {
            d3.selectAll(".st-link").style("stroke", "black");
            pathData = getLinksIds(d);
            ids = pathData.ids;
            nodedata = pathData.nodedata;



            var newHeight = nodedata.length * 230;
            newHeight = Math.max(newHeight, 1000);

            sideSVG.attr("height", newHeight);

            d3.select("#st-side-panel-36082").style("height", newHeight + "px");

            d3.selectAll(".st-link")
              .filter(function(d) {
                return ids.includes(d.id);
              })
              .style("stroke", "red");

            const sidePanel = d3.selectAll("#st-side-panel-36082");

            if (sidePanel.classed("show")) {
              sidePanel.classed("show", false).classed("hide", true);

              setTimeout(function() {
                sideSVG.selectAll("g").remove();

                sidePanel.classed("hide", false).classed("show", true);

                renderNodeData(nodedata);

              }, 300);
            } else {
              sidePanel.classed("hide", false).classed("show", true);
              renderNodeData(nodedata);
            }
          }

          function renderNodeData(nodedata) {
            nodedata.slice().reverse().forEach(function(node, i) {
              stLog("debug", node.data, "Nody" + i);
              stLog("debug", sideSVG, "SVG");

              const group = sideSVG.append("g")
                .attr("class", "node-group")
                .attr("transform", `translate(150, ${200 * i + 100})`)
                .datum(node);

              group.each(function(d) {
                if (treeData.tree_type == classification) {
                  if (!node.data.is_leaf) {
                    processClassificationNode.call(
                      this,
                      treeData,
                      tooltipBody,
                      tooltipModal,
                      globalX,
                      globalXExtent,
                      globalY,
                      globalYExtent,
                      click,
                      histogramWidth,
                      histogramHeight,
                      rectWidth,
                      rectHeight,
                      colors,
                      node
                    );
                  }
                  if (node.data.is_leaf) {
                    processClassificationLeaf.call(
                      this,
                      treeData,
                      pieWidth,
                      pieHeight,
                      rectWidth,
                      rectHeight,
                      scatterplotWidth,
                      scatterplotHeight,
                      colors,
                      maxSample,
                      showpath,
                      d3,
                      tooltipBody,
                      tooltipModal,
                      d
                    );
                  }
                }
                if (treeData.tree_type == regr) {
                  if (!node.data.is_leaf) {
                    processRegressionNode.call(
                      this,
                      d,
                      treeData,
                      scatterplotWidth,
                      scatterplotHeight,
                      histogramWidth,
                      histogramHeight,
                      rectWidth,
                      rectHeight,
                      tooltipBody,
                      tooltipModal,
                      colors
                    );
                  }
                  if (node.data.is_leaf) {
                    processRegressionLeaf.call(
                      this,
                      d,
                      treeData,
                      scatterplotLeafWidth,
                      scatterplotLeafHeight,
                      rectHeight,
                      tooltipBody,
                      tooltipModal,
                      click,
                      showpath
                    );
                  }
                }
              });
            });

          }



          function getLinksIds(node) {
            var ids = []
            var nodedata = []
            function linkDFS(node) {
              stLog("debug", node, "Node w dfsie");
              ids.push(node.id)
              nodedata.push(node)
              if (node.parent) {
                linkDFS(node.parent);
              }
            }
            linkDFS(node)
            let pathData = {
              ids: ids,
              nodedata: nodedata
            }
            return pathData;
          }



          if (!treeData.tree_type.startsWith(nodata))
            var Linkbutton = d3
              .selectAll("#toolbar-36082")
              .append("button")
              .html(svgLine)
              .attr("id", "boldLink")
              .attr("class", "st-option-button")
              .on("click", boldClick)
              .on("mouseover", mouseover)
              .on("mouseleave", mouseleave)
              .on("mousemove", function(d) {
                mousemoveButton(
                  event,
                  "Change line tickness scalling in reference to samples in child node",
                );
              });


          d3.selectAll("#st-close-button-36082").on("click", function() {
            d3.selectAll("#st-side-panel-36082").classed("show", false).classed("hide", true);
            setTimeout(function() {
              sideSVG.selectAll("g").remove();
            }, 300);
          });

          var resetZoomButton = d3
            .selectAll("#toolbar-36082")
            .append("button")
            .html(svgZoom)
            .attr("id", "resetZoom")
            .attr("class", "st-option-button")
            .on("click", resetZoom)
            .on("mouseover", mouseover)
            .on("mouseleave", mouseleave)
            .on("mousemove", function(d) {
              mousemoveButton(event, "Zoom reset");
            });

          if (treeData.tree_type == classification) {
            var xButton = d3
              .selectAll("#toolbar-36082")
              .append("button")
              .html(svgXAxis)
              .attr("id", "changeXAxis")
              .attr("class", "st-option-button")
              .on("click", xClick)
              .on("mouseover", mouseover)
              .on("mouseleave", mouseleave)
              .on("mousemove", function(d) {
                mousemoveButton(event, "Change Scale on X Axis");
              });

            var yButton = d3
              .selectAll("#toolbar-36082")
              .append("button")
              .html(svgYAxis)
              .attr("id", "changeYAxis")
              .attr("class", "st-option-button")
              .on("click", yClick)
              .on("mouseover", mouseover)
              .on("mouseleave", mouseleave)
              .on("mousemove", function(d) {
                mousemoveButton(event, "Change Scale on Y Axis");
              });
          }



          function boldClick() {
            boldLinks = !boldLinks;
            update(treeRoot, true);
          }

          function saveSvg() {
            var svgElement = document.getElementById("mySVG-36082");

            var serializer = new XMLSerializer();
            var svgString = serializer.serializeToString(svgElement);

            var blob = new Blob([svgString], {
              type: "image/svg+xml;charset=utf-8",
            });

            var downloadLink = document.createElement("a");
            downloadLink.href = URL.createObjectURL(blob);
            downloadLink.download = "myDiagram.svg";

            document.body.appendChild(downloadLink);
            downloadLink.click();

            document.body.removeChild(downloadLink);
          }

          function xClick() {
            globalX = !globalX;
            update(treeRoot, true);
          }

          function yClick() {
            globalY = !globalY;
            update(treeRoot, true);
          }

          const myToolbar = d3.selectAll("#toolbar-36082");

          var uArr = [];

          var dropdownDepth = myToolbar
            .append("select")
            .attr("id", "st-depth-dropdown")
            .attr("class", "st-dropdown")
            .on("change",
              handleDepthChange
            );

          function handleDepthChange(event, optDepth = "optional") {
            var depth = 0;
            if (optDepth !== "optional") {
              depth = optDepth;
            }
            else {
              depth = extractNumber(this.value)+1;
            }
            if (depth != null) {
              if (isLocked) {
                return;
              }
              isLocked = true;
              d3.selectAll("#st-depth-dropdown").attr("disabled", "disabled");
              showDepth(treeRoot, 0, depth, true);
              uArr.forEach(function(d) {
                update(d, false);
              });
              dropdownDepth.property("value", optionsDepth[depth - 1]);

              setTimeout(() => {
                isLocked = false;
                d3.selectAll("#st-depth-dropdown").attr("disabled", null);
              }, duration);

              uArr = [];
              resetZoom();
            }
          }


          if (valid && treeData.tree_type == classification) {
            let dropdownColors = myToolbar
              .append("select")
              .attr("id", "st-color-dropdown")
              .attr("class", "st-dropdown")
              .on("change", function() {
                var number = extractNumber(this.value);
                colors = allColors.slice((number - 1) * colorSize, number * colorSize);
                if (treeData.feature_names.length > colors.length) {
                  let missingColors = treeData.feature_names.length - colors.length;

                  function getRandomColor() {
                    let letters = '0123456789ABCDEF';
                    let color = '#';
                    for (let i = 0; i < 6; i++) {
                      color += letters[Math.floor(Math.random() * 16)];
                    }
                    return color;
                  }

                  for (let i = 0; i < missingColors; i++) {
                    colors.push(getRandomColor());
                  }
                }
                update(treeRoot, true);
              });



            let optionsColors = [];

            d3.selectAll(".st-option-button")
              .style("user-select", "none")
              .style("-webkit-user-select", "none")
              .style("-moz-user-select", "none")
              .style("-ms-user-select", "none");

            for (let i = 1; i <= allColors.length / 20; i++) {
              optionsColors.push(`Palette = ${i}`);
            }

            dropdownColors
              .selectAll("option")
              .data(optionsColors)
              .enter()
              .append("option")
              .attr("value", (d) => d)
              .text((d) => d);
          }

          function redirectToPage() {
            window.location.href = "https://mljar.com/";
          }

          setTimeout(function() {

            logoURL = "https://mljar.com/images/logo/logo_blue_white.svg";
            let logo = d3
              .select("#toolbar-36082")
              .append("button")
              .attr("class", "st-option-button")
              .style("background", "transparent")
              .style("border", "none")
              .style("cursor", "pointer")
              .style("padding", "0")
              .style("position", "relative")
              .append("img")
              .attr("src", logoURL)
              .style("height", "50px")
          }, 100);


          function showDepth(d, currentDepth, depth, colapse) {
            currentDepth++;
            if (currentDepth < depth) {
              if (d._children) {
                d.children = d._children;
                d._children = null;
                var flag = false;
                if (colapse == true) {
                  flag = true;
                  colapse = false;
                }
              }
              if (d.children) {
                d.children.forEach(function(child) {
                  showDepth(child, currentDepth, depth, colapse);
                });
                if (flag == true) {
                  update(d, false);
                }
              }
            } else if (currentDepth > depth) {
              if (d.children) {
                d._children = d.children;
                d.children = null;
              }
              if (d._children) {
                d._children.forEach(function(child) {
                  showDepth(child, currentDepth, depth, colapse);
                });
              }
            } else if (currentDepth == depth) {
              if (d.children) {
                d._children = d.children;
                d.children = null;
              }
              if (d._children) {
                d._children.forEach(function(child) {
                  showDepth(child, currentDepth, depth, colapse);
                });
              }
              if (colapse == true) {
                uArr.push(d);
              }
            }
          }

          var maxDepth = 0;

          function getTreeDepth(d, depth) {
            depth++;
            maxDepth = Math.max(depth, maxDepth);
            if (d.children) {
              d.children.forEach(function(child) {
                getTreeDepth(child, depth);
              });
            }
            if (d._children) {
              d._children.forEach(function(child) {
                getTreeDepth(child, depth);
              });
            }
          }
          getTreeDepth(treeRoot, maxDepth);

          var optionsDepth = [];

          for (let i = 1; i <= maxDepth; i++) {
            optionsDepth.push(`Depth = ${i-1}`);
          }

          dropdownDepth
            .selectAll("option")
            .data(optionsDepth)
            .enter()
            .append("option")
            .attr("value", (d) => d)
            .text((d) => d);

          dropdownDepth.property("value", optionsDepth[Math.min(startDepth - 1, optionsDepth.length - 1)]);


          function collapse(d, depth, maxdepth) {
            depth++;
            if (d.children && depth == maxdepth) {
              d._children = d.children;
              d.children = null;
            }
            else {
              d.children.forEach(function(child) {
                showDepth(child, depth, maxdepth);
              });
            }
          }
          function extractNumber(str) {
            const match = str.match(/\d+/);

            if (match) {
              return parseInt(match[0], 10);
            }

            return null;
          }

        }
      });
    })
    .catch((error) => {
      stLog("error", error.message);
    });
}
buildTree(
);

function processClassificationNode(treeData, tooltipBody, tooltipModal, globalX, globalXExtent, globalY, globalYExtent, click, histogramWidth, histogramHeight, rectWidth, rectHeight, colors, d) {
  stLog("debug", this, "this")
  var isSampleExist = false;
  if (!d.data.is_leaf) {
    if (treeData.show_sample != "nodata") {
      stLog("debug", treeData.show_sample, "treedatasample");
      isSampleExist = true;
    }
    var isSampleExistInThisNode = true;
    if (isSampleExist) {
      isSampleExistInThisNode = true;
    }
    else {
      isSampleExistInThisNode = false;
    }



    const featureIndex = d.data.feature;


    const uniqueTargets = [...new Set(treeData.data_target)];
    const maxTarget = Math.max(...uniqueTargets); // Znajdujemy najwysz warto
    let filteredData = Array.from({ length: maxTarget + 1 }, () => []);
    stLog("debug",filteredData,"filtered");
    stLog("debug",treeData.data_target,"data_target");
    treeData.data_feature.forEach((row, index) => {
      const target = treeData.data_target[index];
      stLog("debug",target,"target"); 
      stLog("debug",filteredData,"row");
      filteredData[target].push(row);
    });

    var xExtent = [Infinity, -Infinity];

    d.data.start_end_x_axis.forEach((currentElement, index) => {
      if (currentElement[0] != "notexist") {
        filteredData.forEach((twoDimArray, i) => {
          filteredData[i] = twoDimArray.filter(
            (rowArray) => rowArray[index] < currentElement[0],
          );
        });
      }
      if (currentElement[1] != "notexist") {
        filteredData.forEach((twoDimArray, i) => {
          filteredData[i] = twoDimArray.filter(
            (rowArray) => rowArray[index] > currentElement[1],
          );
        });
      }
    });

    if (isSampleExist) {

      d.data.start_end_x_axis.forEach((currentElement, i) => {
        const sampleValue = treeData.show_sample[i];

        if (currentElement[0] != "notexist" && sampleValue > currentElement[0]) {
          isSampleExistInThisNode = false;
        }

        if (currentElement[1] != "notexist" && sampleValue < currentElement[1]) {
          isSampleExistInThisNode = false;
        }
      });
    }

    let featureData = filteredData.map((subArray) =>
      subArray.map((innerArray) => innerArray[featureIndex]),
    );

    const removedIndices = [];

    let indicesArray = Array.from(
      { length: featureData.length + removedIndices.length },
      (_, i) => i,
    );

    featureData = featureData
      .map((twoDimArray, index) => {
        const filteredArray = twoDimArray.filter(
          (value) => value !== undefined && value !== null,
        );
        if (filteredArray.length === 0) {
          removedIndices.push(index);
        }
        return filteredArray;
      })
      .filter((twoDimArray) => twoDimArray.length > 0);

    let removedSet = new Set(removedIndices);

    indicesArray = indicesArray.filter(
      (value) => !removedSet.has(value),
    );

    featureData.map((currentValue) => {
      var tempxExtent = d3.extent(currentValue);
      xExtent[0] = Math.min(xExtent[0], tempxExtent[0]);
      xExtent[1] = Math.max(xExtent[1], tempxExtent[1]);
    });

    xExtent[0] = xExtent[0] - 0.2;
    xExtent[1] = xExtent[1] + 0.2;

    if (globalX) {
      xExtent = globalXExtent[featureIndex];
    }

    if (xExtent[0] > d.data.threshold) {
      xExtent[0] = d.data.threshold - 0.2
    }
    if (xExtent[1] < d.data.threshold) {
      xExtent[1] = d.data.threshold + 0.2
    }


    if (xExtent[0] > treeData.show_sample[featureIndex]) {
      xExtent[0] = treeData.show_sample[featureIndex] - 0.2
    }
    if (xExtent[1] < treeData.show_sample[featureIndex]) {
      xExtent[1] = treeData.show_sample[featureIndex] + 0.2
    }

    const xScale = d3
      .scaleLinear()
      .domain(xExtent)
      .range([0, histogramWidth]);

    d3.select(this)
      .append("rect")
      .attr("class", "histogram-background")
      .attr("x", -(histogramWidth / 2) - 25)
      .attr("y", -10)
      .attr("width", rectWidth)
      .attr("height", rectHeight)
      .attr("stroke-width", isSampleExistInThisNode ? 4 : 1)
      .attr("stroke", "#545454")
      .attr("rx", 10)
      .attr("ry", 10)
      .style("fill", "#ffffff")
      .on("click", click);

    const mousemoveAllData = function(event, d) {
      stLog("debug", d, "mousemoveAllData")
      tooltipBody
        .html(
          `<b>All Data</b>:<br>Class distribution: ${d.data.class_distribution}
              <br>Impurity: ${d.data.impurity}
              <br>Samples: ${d.data.samples}
              <br>Threshold: ${d.data.threshold}
              <br>Treeclass: ${d.data.treeclass}`,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1);

      tooltipModal
        .html(
          `<b>All Data</b>:<br>Class distribution: ${d.data.class_distribution}
              <br>Impurity: ${d.data.impurity}
              <br>Samples: ${d.data.samples}
              <br>Threshold: ${d.data.threshold}
              <br>Treeclass: ${d.data.treeclass}`,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1);
    };

    const mouseleaveAllData = function(event, d) {
      tooltipBody.style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      tooltipModal.style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

    };

    stLog("debug", this, "This");

    d3.select(this)
      .append("text")
      .attr("class", "st-target")
      .attr("x", 0)
      .attr("y", rectHeight + 15)
      .style("text-anchor", "middle")
      .style("font-size", "18px")
      .text(treeData.feature_names[featureIndex])
      .on("mousemove", mousemoveAllData)
      .on("mouseleave", mouseleaveAllData)
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none");

    const xDomain = xScale.domain();
    const xTickValues = [
      xDomain[0],
      d.data.threshold,
      xDomain[1],
    ];

    d3.select(this)
      .append("g")
      .attr("class", "xAxis")
      .attr(
        "transform",
        `translate(${-histogramWidth / 2}, ${histogramHeight})`,
      )

      .call(
        d3
          .axisBottom(xScale)
          .tickSize(0)
          .tickPadding(8)
          .tickValues(xTickValues)
          .tickFormat(d3.format(",.1f")),
      )
      .selectAll(".tick")
      .attr("class", "xAxis-text")
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none")
      .style("fill", "black");


    d3.select(this).selectAll(".domain")
      .style("stroke", "black");

    const yScale = d3.scaleLinear().range([histogramHeight, 0]);

    const yAxis = d3.select(this).append("g");
    /*
  const GridLine = () => d3.axisLeft().scale(yScale);
  d3.select(this)
    .append("g")
    .attr("class", "grid")
    .attr("transform", `translate(${-histogramWidth / 2},0)`)
    .call(
      GridLine()
        .tickSize(-histogramWidth, 0, 0)
        .tickFormat("")
        .ticks(10),
    );
*/
    const histogram = d3
      .bin()
      .domain(xScale.domain())
      .thresholds(xScale.ticks(20));

    const binsData = featureData.map((data) => histogram(data));

    stLog("debug", binsData, "binsData")

    const stackedData = d3
      .stack()
      .keys(d3.range(featureData.length))
      .value((d, key) => (d[key] ? d[key].length : 0))(
        d3.transpose(binsData),
      );



    var yExtent = [0, 0];
    yExtent[0] = 0;
    yExtent[1] = d3.max(stackedData, (d) =>
      d3.max(d, (d) => d[1]),
    );

    globalYExtent[featureIndex][1] = Math.max(
      globalYExtent[featureIndex][1],
      d3.max(stackedData, (d) => d3.max(d, (d) => d[1])),
    );
    if (globalY) {
      yExtent = globalYExtent[featureIndex];
    }
    yScale.domain(yExtent);

    const yDomain = yScale.domain();
    const yTickValues = [
      yDomain[0],
      yDomain[0] + (yDomain[1] - yDomain[0]) / 2,
      yDomain[1],
    ];
    stLog("debug", yTickValues, "YTICKVALUES")
    if (yTickValues.every(value => !isNaN(value))) {
      yAxis
        .call(
          d3
            .axisLeft(yScale)
            .tickSize(0)
            .tickPadding(4)
            .tickValues(yTickValues)
            .tickFormat(d3.format(",.0f")),
        )
        .attr("class", "yAxis")
        .attr("transform", `translate(${-histogramWidth / 2},0)`)
        .call((d) => d.select(".domain").remove())
        .style("user-select", "none")
        .style("-webkit-user-select", "none")
        .style("-moz-user-select", "none")
        .style("-ms-user-select", "none")
        .style("fill", "black");
    }


    d3.select(this).selectAll(".domain")
      .style("stroke", "black");

    const mouseover = function(d) {
      tooltipModal.style("opacity", 1);
      tooltipBody.style("opacity", 1);

      d3.select(this).style("stroke", "#EF4A60");
    };

    const mouseleave = function(d) {
      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("stroke", "black");
    };

    const mousemove = function(event, d) {
      tooltipBody
        .html(
          `<b>${treeData.target_names[d.class]}</b>: ${d[1] - d[0]}`,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipModal
        .html(
          `<b>${treeData.target_names[d.class]}</b>: ${d[1] - d[0]}`,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };

    let nodeToClick = d;

    stLog("debug", stackedData, "stackedData");
    stLog("debug", d.data, "node:");

    d3.select(this)
      .selectAll("g.layer")
      .data(stackedData)
      .enter()
      .append("g")
      .attr("class", "layer")
      .style("fill", (d, i) => colors[indicesArray[i]])
      .on("click", function() {
        click(source, nodeToClick);
      })
      .selectAll("rect.bar")
      .data((d, i) =>
        d.map((item) => ({ ...item, class: indicesArray[i] })),
      )
      .enter()
      .append("rect")
      .attr("class", "bar")
      .attr("x", (d) => {
        return xScale(d.data[0].x0);
      })
      .attr("y", (d) => {
        if (isNaN(yScale(d[1]))) {
          return 0;
        }
        else {
          return yScale(d[1]);
        }
      })
      .attr("height", (d) => {
        if (isNaN(yScale(d[0]) - yScale(d[1]))) {
          return 0;
        }
        else {
          return yScale(d[0]) - yScale(d[1]);
        }
      })
      .attr(
        "width",
        (d) => xScale(d.data[0].x1) - xScale(d.data[0].x0),
      )
      .attr("transform", `translate(${-histogramWidth / 2},0)`)
      .attr("stroke", "black")
      .on("mouseover", mouseover)
      .on("mouseleave", mouseleave)
      .on("mousemove", mousemove);
    stLog("debug", "abc")
    var threshold = d.data.threshold;
    d3.select(this)
      .append("line")
      .attr("class", "threshold-line")
      .attr("x1", xScale(threshold))
      .attr("x2", xScale(threshold))
      .attr("y1", 0)
      .attr("y2", histogramHeight)
      .attr("stroke", "black")
      .attr("transform", `translate(${-histogramWidth / 2},0)`)
      .attr("stroke-width", 2)
      .attr("stroke-dasharray", "5,5");

    var mouseovertriangle = function(d) {


      tooltipBody.style("opacity", 1);
      tooltipModal.style("opacity", 1);

      d3.select(this).style("fill", "red").style("stroke", "red");
    };

    var mouseleavetriangle = function(d) {


      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("fill", "green").style("stroke", "green");
    };


    var mousemovetriangle = function(event, d) {

      tooltipModal
        .html(
          treeData.feature_names.map((feature, index) => {
            const sampleValue = treeData.show_sample[index];
            const formattedValue = !isNaN(parseFloat(sampleValue)) ? parseFloat(sampleValue).toFixed(3) : 'N/A';
            return `<b>${feature}:</b> ${formattedValue}`;
          }).join(",")
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipBody
        .html(
          treeData.feature_names.map((feature, index) => {
            const sampleValue = treeData.show_sample[index];
            const formattedValue = !isNaN(parseFloat(sampleValue)) ? parseFloat(sampleValue).toFixed(3) : 'N/A';
            return `<b>${feature}:</b> ${formattedValue}`;
          }).join(",")
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };
    var color = "green";
    var triangleSize = 25;
    var verticalTransform = histogramHeight - Math.sqrt(triangleSize) + 15;

    var triangle = d3.symbol()
      .type(d3.symbolTriangle)
      .size(triangleSize);

    if (isSampleExistInThisNode) {
      stLog("debug", d, "Exist");
      d3.select(this).append("path")
        .attr("d", triangle)
        .attr("class", "st-triangle")
        .style("fill",color)
        .style("stroke-width",1)
        .style("stroke-opacity",1)
        .attr("transform", function(d) {
          return "translate(" + (-histogramWidth / 2 + xScale(treeData.show_sample[featureIndex])) + "," + verticalTransform + ")";
        })
        .on("mouseover", mouseovertriangle)
        .on("mouseleave", mouseleavetriangle)
        .on("mousemove", mousemovetriangle);
    }



  }

}


function processClassificationLeaf(
  treeData,
  pieWidth,
  pieHeight,
  rectWidth,
  rectHeight,
  scatterplotWidth,
  scatterplotHeight,
  colors,
  maxSample,
  showpath,
  d3,
  tooltipBody,
  tooltipModal,
  d
) {

  if (d.data.is_leaf) {

    const featureIndex = d.data.feature;

    if (treeData.show_sample != "nodata") {
      stLog("debug", treeData.show_sample, "treedatasample");
      isSampleExist = true;
    }
    var isSampleExistInThisNode = true;
    if (isSampleExist) {
      isSampleExistInThisNode = true;
    }
    else {
      isSampleExistInThisNode = false;
    }
    const classDistribution = d.data.class_distribution[0];
    const removedIndexes = [];
    const data = classDistribution
      .map((value, index) => {
        return {
          target_name: `${treeData.target_names[index]}`,
          classDistributionValue: value,
          index: index,
        };
      })
      .filter((item) => {
        if (item.classDistributionValue === 0) {
          removedIndexes.push(item.index);
          return false;
        }
        return true;
      })
      .map((item) => {
        return {
          target_name: item.target_name,
          classDistributionValue: item.classDistributionValue,
        };
      });
    var isSampleExist = false;


    if (treeData.show_sample != "nodata") {
      stLog("debug", treeData.show_sample, "treedatasample");
      isSampleExist = true;
    }
    var isSampleExistInThisNode = true;
    if (isSampleExist) {
      isSampleExistInThisNode = true;
    }
    else {
      isSampleExistInThisNode = false;
    }

    let indicesArray = Array.from(
      { length: classDistribution.length },
      (_, i) => i,
    );

    let removedSet = new Set(removedIndexes);

    indicesArray = indicesArray.filter(
      (value) => !removedSet.has(value),
    );


    if (isSampleExist) {

      d.data.start_end_x_axis.forEach((currentElement, i) => {
        const sampleValue = treeData.show_sample[i];

        if (currentElement[0] != "notexist" && sampleValue > currentElement[0]) {
          isSampleExistInThisNode = false;
        }

        if (currentElement[1] != "notexist" && sampleValue < currentElement[1]) {
          isSampleExistInThisNode = false;
        }
      });
    }

    var allCurrentSamples = 0;

    for (
      let i = 0;
      i < d.data.class_distribution[0].length;
      i++
    ) {
      allCurrentSamples =
        allCurrentSamples +
        parseInt(d.data.class_distribution[0][i]);
    }

    const radius = Math.max(
      20,
      (Math.min(pieWidth, pieHeight) / 2) *
      Math.sqrt(allCurrentSamples / maxSample),
    );
    const pie = d3
      .pie()
      .value((d) => d.classDistributionValue)
      .sort(null);

    const dataPrepared = pie(data);

    const arc = d3.arc().innerRadius(0).outerRadius(radius);

    data.forEach(function(d) {
      d.classDistributionValue = +d.classDistributionValue;
      d.enabled = true;
    });

    const total = d3.sum(
      data.map(function(d) {
        return d.enabled ? d.classDistributionValue : 0;
      }),
    );

    const mouseover = function(d) {
      tooltipBody.style("opacity", 1);
      tooltipModal.style("opacity", 1);
      d3.select(this).style("stroke", "#EF4A60");
    };

    const mouseleave = function(d) {
      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("stroke", "black");
    };

    const mousemove = function(event, d) {
      tooltipBody
        .html(
          `<b>${d.data.target_name}</b>: ${d.data.classDistributionValue}`,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipModal
        .html(
          `<b>${d.data.target_name}</b>: ${d.data.classDistributionValue}`,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };

    if (dataPrepared[0] && 'data' in dataPrepared[0]) {
      let nodeToClick = d3.select(this).datum()
      d3.select(this)
        .selectAll("path")
        .data(dataPrepared)
        .join("path")
        .attr("class", "piechart")
        .attr("d", arc)
        .attr("fill", (d, i) => colors[indicesArray[i]])
        .attr("transform", `translate(${10},${radius})`)
        .attr("stroke", "black")
        .on("mouseover", mouseover)
        .on("mouseleave", mouseleave)
        .on("mousemove", mousemove)
        .on("click", function() {
          showpath(nodeToClick)
        })
        .style("stroke-width", isSampleExistInThisNode ? "4px" : "2px")
        .each(function(d) {
          this._current = d;
        })
      stLog("debug", isSampleExistInThisNode, "Exist Sample true false");


      d3.select(this)
        .append("g")
        .attr("class", "st-text-pie")
        .attr("text-anchor", "middle")
        .selectAll(".st-text-pie")
        .data(dataPrepared)
        .join("g")
        .attr(
          "transform",
          (d, i) => `translate(10,${radius * 2 + 20 + i * 40})`,
        )
        .each(function(d, i) {
          const group = d3.select(this);

          group
            .append("text")
            .attr("class", "st-pie-target")
            .attr("x", 0)
            .attr("y", 0)
            .attr("fill", "black")
            .style("text-anchor", "middle")
            .style("font-size", "18px")
            .text(d.data.target_name)
            .style("user-select", "none")
            .style("-webkit-user-select", "none")
            .style("-moz-user-select", "none")
            .style("-ms-user-select", "none");


          group
            .append("text")
            .attr("class", "st-pie-target2")
            .attr("x", 0)
            .attr("y", 20)
            .attr("fill", "black")
            .style("text-anchor", "middle")
            .style("font-size", "18px")
            .text(d.data.classDistributionValue.toLocaleString())
            .style("user-select", "none")
            .style("-webkit-user-select", "none")
            .style("-moz-user-select", "none")
            .style("-ms-user-select", "none");

        });
    }
    else {

      d3.select(this)
        .append("rect")
        .attr("class", "histogram-background")
        .attr("x", -(scatterplotWidth / 2) - 5)
        .attr("y", -10)
        .attr("width", rectWidth - 40)
        .attr("height", rectHeight)
        .attr("stroke-width", 1)
        .attr("stroke", "#545454")
        .attr("rx", 10)
        .attr("ry", 10)
        .style("fill", "#ffffff");


      d3.select(this)
        .append("text")
        .attr("dy", ".0em")
        .attr("y", 10)
        .attr("class", "st-target")
        .style("text-anchor", "middle")
        .text((d) => "Samples " + d.data.samples)
        .style("-webkit-user-select", "none")
        .style("-moz-user-select", "none")
        .style("-ms-user-select", "none");


      d3.select(this)
        .append("text")
        .attr("dy", ".0em")
        .attr("y", 40)
        .attr("class", "st-target")
        .style("text-anchor", "middle")
        .text((d) => "Value [" + d.data.class_distribution + "]")
        .style("-webkit-user-select", "none")
        .style("-moz-user-select", "none")
        .style("-ms-user-select", "none");


      d3.select(this)
        .append("text")
        .attr("dy", ".0em")
        .attr("y", 70)
        .attr("class", "st-target")
        .style("text-anchor", "middle")
        .text((d) => "Class " + d.data.treeclass)
        .style("-webkit-user-select", "none")
        .style("-moz-user-select", "none")
        .style("-ms-user-select", "none");

    }
  }
}

function processRegressionNode(
  d,
  treeData,
  scatterplotWidth,
  scatterplotHeight,
  histogramWidth,
  histogramHeight,
  rectWidth,
  rectHeight,
  tooltipBody,
  tooltipModal,
  colors
) {

  if (!d.data.is_leaf) {

    const featureIndex = d.data.feature;
    let filteredData = treeData.data_feature.map(
      (row) => row[d.data.feature],
    );

    let combinedData = filteredData.map((value, index) => [
      value,
      treeData.data_target[index],
    ]);
    let indexSet = new Set();

    d.data.start_end_x_axis.forEach((currentElement, index) => {
      if (currentElement[0] != "notexist") {
        treeData.data_feature.forEach((value, innerIndex) => {
          if (value[index] > currentElement[0]) {
            indexSet.add(innerIndex);
          }
        });
      }
      if (currentElement[1] != "notexist") {
        treeData.data_feature.forEach((value, innerIndex) => {
          if (value[index] < currentElement[1]) {
            indexSet.add(innerIndex);
          }
        });
      }
    });


    var isSampleExist = false;


    if (treeData.show_sample != "nodata") {
      stLog("debug", treeData.show_sample, "treedatasample");
      isSampleExist = true;
    }
    var isSampleExistInThisNode = true;
    if (isSampleExist) {
      isSampleExistInThisNode = true;
    }
    else {
      isSampleExistInThisNode = false;
    }


    if (isSampleExist) {

      d.data.start_end_x_axis.forEach((currentElement, i) => {
        const sampleValue = treeData.show_sample[i];

        if (currentElement[0] != "notexist" && sampleValue > currentElement[0]) {
          isSampleExistInThisNode = false;
        }

        if (currentElement[1] != "notexist" && sampleValue < currentElement[1]) {
          isSampleExistInThisNode = false;
        }
      });
    }

    let indexesToRemove = Array.from(new Set([...indexSet]));

    indexesToRemove.sort((a, b) => b - a);

    indexesToRemove.forEach((index) => {
      if (index >= 0 && index < combinedData.length) {
        combinedData.splice(index, 1);
      }
    });

    d3.select(this)
      .append("rect")
      .attr("class", "histogram-background")
      .attr("x", -(scatterplotWidth / 2) - 25)
      .attr("y", -10)
      .attr("width", rectWidth)
      .attr("height", rectHeight)
      .attr("stroke-width", isSampleExistInThisNode ? 4 : 1)
      .attr("stroke", "#545454")
      .attr("rx", 10)
      .attr("ry", 10)
      .style("fill", "#ffffff");

    let combinedDataValues = combinedData.map((item) => item[0]);

    function calculateAverages(data, threshold) {
      let sumBelowThreshold = 0;
      let countBelowThreshold = 0;
      let sumAboveOrEqualThreshold = 0;
      let countAboveOrEqualThreshold = 0;

      data.forEach((item) => {
        if (item[0] < threshold) {
          sumBelowThreshold += item[1];
          countBelowThreshold++;
        } else {
          sumAboveOrEqualThreshold += item[1];
          countAboveOrEqualThreshold++;
        }
      });

      const averageBelowThreshold =
        sumBelowThreshold / countBelowThreshold;
      const averageAboveOrEqualThreshold =
        sumAboveOrEqualThreshold / countAboveOrEqualThreshold;

      return {
        averageBelowThreshold,
        averageAboveOrEqualThreshold,
      };
    }

    const average = calculateAverages(
      combinedData,
      d.data.threshold,
    );
    xExtent = d3.extent(combinedDataValues)
    if (xExtent[0] === NaN || xExtent[0] === undefined || xExtent[0] > d.data.threshold) {
      xExtent[0] = d.data.threshold - 0.2;
    }
    if (xExtent[1] === NaN || xExtent[1] === undefined || xExtent[1] < d.data.threshold) {
      xExtent[1] = d.data.threshold + 0.2;
    }


    if (xExtent[0] > treeData.show_sample[featureIndex]) {
      xExtent[0] = treeData.show_sample[featureIndex] - 0.2
    }
    if (xExtent[1] < treeData.show_sample[featureIndex]) {
      xExtent[1] = treeData.show_sample[featureIndex] + 0.2
    }




    stLog("debug", xExtent, "xExtent")

    const xScale = d3
      .scaleLinear()
      .domain(xExtent)
      .nice()
      .range([0, scatterplotWidth]);

    const xDomain = xScale.domain();

    const xTickValues = [
      xDomain[0],
      d.data.threshold,
      xDomain[1],
    ];

    d3.select(this)
      .append("g")
      .attr(
        "transform",
        `translate(${-scatterplotWidth / 2}, ${scatterplotHeight})`,
      )
      .attr("class", "xAxis")
      .call(
        d3
          .axisBottom(xScale)
          .tickSize(0)
          .tickValues(xTickValues)
          .tickPadding(8),
      )
      .selectAll(".tick")
      .attr("class", "xAxis-text")
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none")
      .style("fill", "black");

    d3.select(this).selectAll(".domain")
      .style("stroke", "black");
    yExtent = d3.extent(treeData.data_target)
    const yScale = d3
      .scaleLinear()
      .domain(yExtent)
      .nice()
      .range([scatterplotHeight, 0]);

    d3.select(this)
      .append("g")
      .call(
        d3.axisLeft(yScale).tickSize(0).ticks(4).tickPadding(4),
      )
      .call((d) => d.select(".domain"))
      .attr("transform", `translate(${-scatterplotWidth / 2}, 0)`)
      .attr("class", "yAxis")
      .selectAll(".tick")
      .attr("class", "yAxis-text")
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none")
      .style("fill", "black");


    d3.select(this).selectAll(".domain")
      .style("stroke", "black");

    /*
                const GridLineH = function () {
                    return d3.axisLeft().scale(yScale);
                };
    
                d3.select(this)
                    .append("g")
                    .attr("class", "st-grid")
                    .call(
                        GridLineH()
                            .tickSize(-histogramWidth, 0, 0)
                            .tickFormat("")
                            .ticks(6),
                    )
                    .attr("transform", `translate(${-histogramWidth / 2}, ${0})`);
 
                const GridLineV = function () {
                    return d3.axisBottom().scale(xScale);
                };
 
                d3.select(this)
                    .append("g")
                    .attr("class", "st-grid")
                    .call(
                        GridLineV()
                            .tickSize(histogramHeight, 0, 0)
                            .tickFormat("")
                            .ticks(5),
                    )
                    .attr("transform", `translate(${-histogramWidth / 2}, ${0})`);
   */

    const mouseover = function(d) {
      tooltipBody.style("opacity", 1);
      d3.select(this).style("fill", "red");

      tooltipModal.style("opacity", 1);
      d3.select(this).style("fill", "red");
    };

    const mouseleave = function(d) {
      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");
      d3.select(this).style("fill", "blue");

      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("fill", "blue");
    };

    const mouseoverline = function(d) {
      tooltipBody.style("opacity", 1);
      d3.select(this).style("stroke", "red");

      tooltipModal.style("opacity", 1);
      d3.select(this).style("stroke", "red");
    };

    const mouseleaveline = function(d) {
      tooltipBody.style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("stroke", "black");

      tooltipModal.style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("stroke", "black");
    };

    const mousemovecircle = function(event, d) {
      tooltipBody
        .html(`<b>(X,Y):</b> (${d[0]},${d[1]})`)
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipModal
        .html(`<b>(X,Y):</b> (${d[0]},${d[1]})`)
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };

    d3.select(this)
      .append("g")
      .selectAll("g")
      .data(combinedData)
      .join("circle")
      .attr("cx", (d, i) => xScale(combinedData[i][0]))
      .attr("cy", (d, i) => yScale(combinedData[i][1]))
      .attr("r", 2)
      .attr(
        "transform",
        `translate(${-scatterplotWidth / 2}, ${0})`,
      )
      .style("fill", "blue")
      .style("fill-opacity", 0.5)
      .on("mouseover", mouseover)
      .on("mouseleave", mouseleave)
      .on("mousemove", mousemovecircle);

    const mousemoveavaragebelow = function(event, d) {
      tooltipBody
        .html(`<b>Avarage:</b> ${average.averageBelowThreshold} `)
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipModal
        .html(`<b>Avarge:</b> ${average.averageBelowThreshold} `)
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };

    const mousemoveavarageabove = function(event, d) {
      tooltipBody
        .html(
          `<b>Avarage:</b> ${average.averageAboveOrEqualThreshold} `,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipModal
        .html(
          `<b>Avarge:</b> ${average.averageAboveOrEqualThreshold} `,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };

    const mousemoveAllData = function(event, d) {
      tooltipBody
        .html(
          `<b>All Data</b>
              <br>Impurity: ${d.data.impurity}
              <br>Samples: ${d.data.samples}
              <br>Threshold: ${d.data.threshold}`,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1);

      tooltipModal
        .html(
          `<b>All Data</b>:<br>
              <br>Impurity: ${d.data.impurity}
              <br>Samples: ${d.data.samples}
              <br>Threshold: ${d.data.threshold}`,
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px")
        .style("opacity", 1);
    };

    const mouseleaveAllData = function(event, d) {
      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");
    };

    var threshold = d.data.threshold;
    d3.select(this)
      .append("line")
      .attr("class", "threshold-line")
      .attr("x1", xScale(threshold))
      .attr("x2", xScale(threshold))
      .attr("y1", 0)
      .attr("y2", scatterplotHeight)
      .attr("stroke", "black")

      .attr("transform", `translate(${-scatterplotWidth / 2},0)`)
      .attr("stroke-width", 2)
      .attr("stroke-dasharray", "5,5")
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none");

    stLog("debug", average.averageBelowThreshold, "avarage 1:")
    if (!isNaN(average.averageBelowThreshold)) {
      d3.select(this)
        .append("line")
        .attr("class", "average-line")
        .attr("x1", 0)
        .attr("x2", xScale(threshold))
        .attr("y1", yScale(average.averageBelowThreshold))
        .attr("y2", yScale(average.averageBelowThreshold))
        .attr("stroke", "black")
        .attr("transform", `translate(${-histogramWidth / 2},0)`)
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,5")
        .on("mouseover", mouseoverline)
        .on("mouseleave", mouseleaveline)
        .on("mousemove", mousemoveavaragebelow)
        .style("user-select", "none")
        .style("-webkit-user-select", "none")
        .style("-moz-user-select", "none")
        .style("-ms-user-select", "none");
    }


    if (!isNaN(average.averageAboveOrEqualThreshold)) {
      d3.select(this)
        .append("line")
        .attr("class", "average-line")
        .attr("x1", xScale(threshold))
        .attr("x2", xScale(xDomain[1]))
        .attr("y1", yScale(average.averageAboveOrEqualThreshold))
        .attr("y2", yScale(average.averageAboveOrEqualThreshold))
        .attr("stroke", "black")
        .attr("transform", `translate(${-histogramWidth / 2},0)`)
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,5")
        .on("mouseover", mouseoverline)
        .on("mouseleave", mouseleaveline)
        .on("mousemove", mousemoveavarageabove);
    }

    d3.select(this)
      .append("text")
      .attr("class", "st-target")
      .attr("x", 0)
      .attr("y", rectHeight + 15)
      .style("text-anchor", "middle")
      .style("font-size", "18px")
      .text(treeData.feature_names[d.data.feature])
      .on("mousemove", mousemoveAllData)
      .on("mouseleave", mouseleaveAllData)
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none");

    var mouseovertriangle = function(d) {


      tooltipBody.style("opacity", 1);
      tooltipModal.style("opacity", 1);

      d3.select(this).style("fill", "red").style("stroke","red");
    };

    var mouseleavetriangle = function(d) {


      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("fill", "green").style("stroke","green");
    };


    var mousemovetriangle = function(event, d) {

      tooltipModal

        .html(
          treeData.feature_names.map((feature, index) => {
            const sampleValue = treeData.show_sample[index];
            const formattedValue = !isNaN(parseFloat(sampleValue)) ? parseFloat(sampleValue).toFixed(3) : 'N/A';
            return `<b>${feature}:</b> ${formattedValue}`;
          }).join(",")
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipBody
        .html(
          treeData.feature_names.map((feature, index) => {
            const sampleValue = treeData.show_sample[index];
            const formattedValue = !isNaN(parseFloat(sampleValue)) ? parseFloat(sampleValue).toFixed(3) : 'N/A';
            return `<b>${feature}:</b> ${formattedValue}`;
          }).join(",")
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };

    var color = "green";
    var triangleSize = 25;
    var verticalTransform = histogramHeight - Math.sqrt(triangleSize) + 15;  // Dostosuj wysoko transformacji

    var triangle = d3.symbol()
      .type(d3.symbolTriangle)
      .size(triangleSize);

    if (isSampleExistInThisNode) {
      stLog("debug", d, "Exist");
      d3.select(this).append("path")
        .attr("d", triangle)
        .attr("class", "st-triangle")
        .style("stroke-width",1)
        .style("stroke-opacity",1)
        .style("fill", color)
        .attr("transform", function(d) {
          return "translate(" + (-histogramWidth / 2 + xScale(treeData.show_sample[featureIndex])) + "," + verticalTransform + ")";
        })
        .on("mouseover", mouseovertriangle)
        .on("mouseleave", mouseleavetriangle)
        .on("mousemove", mousemovetriangle);
    }
  }

}

function processRegressionLeaf(
  d,
  treeData,
  scatterplotLeafWidth,
  scatterplotLeafHeight,
  rectHeight,
  tooltipBody,
  tooltipModal,
  click,
  showpath
) {
  if (d.data.is_leaf) {
    const featureIndex = d.data.feature;
    var isSampleExist = false;


    if (treeData.show_sample != "nodata") {
      isSampleExist = true;
    }
    var isSampleExistInThisNode = isSampleExist;
    let filteredData = treeData.data_feature.map(
      (row) => row[d.parent.data.feature],
    );

    let combinedData = filteredData.map((value, index) => [
      value,
      treeData.data_target[index],
    ]);
    let indexSet = new Set();

    d.data.start_end_x_axis.forEach((currentElement, index) => {
      if (currentElement[0] != "notexist") {
        treeData.data_feature.forEach((value, innerIndex) => {
          if (value[index] > currentElement[0]) {
            indexSet.add(innerIndex);
          }
        });
      }
      if (currentElement[1] != "notexist") {
        treeData.data_feature.forEach((value, innerIndex) => {
          if (value[index] < currentElement[1]) {
            indexSet.add(innerIndex);
          }
        });
      }
    });

    let indexesToRemove = Array.from(new Set([...indexSet]));

    indexesToRemove.sort((a, b) => b - a);

    indexesToRemove.forEach((index) => {
      if (index >= 0 && index < combinedData.length) {
        combinedData.splice(index, 1);
      }
    });



    if (isSampleExist) {

      d.data.start_end_x_axis.forEach((currentElement, i) => {
        const sampleValue = treeData.show_sample[i];

        if (currentElement[0] != "notexist" && sampleValue > currentElement[0]) {
          isSampleExistInThisNode = false;
        }

        if (currentElement[1] != "notexist" && sampleValue < currentElement[1]) {
          isSampleExistInThisNode = false;
        }
      });
    }

    var nodeToClick = d;

    d3.select(this)
      .append("rect")
      .attr("class", "histogram-background")
      .attr("x", -(scatterplotLeafWidth / 2) - 10)
      .attr("y", -10)
      .attr("width", rectHeight + 20)
      .attr("height", rectHeight - 10)
      .attr("stroke-width", isSampleExistInThisNode ? 4 : 1)
      .attr("stroke", "#545454")
      .attr("rx", 10)
      .attr("ry", 10)
      .style("fill", "#ffffff")
      .on("click", click)
      .on("click", function() {
        showpath(nodeToClick)
      });

    let combinedDataValues = combinedData.map((item) => item[0]);

    function calculateAverage(data) {
      const length = data.length;
      const sum = data.reduce((accumulator, currentValue) => {
        return accumulator + currentValue[1];
      }, 0);

      return sum / length;
    }

    const average = calculateAverage(combinedData);
    var xExtent = d3.extent(combinedDataValues);
    xExtent[0] = xExtent[0] - 0.2;
    xExtent[1] = xExtent[1] + 0.2;

    if (xExtent[0] > treeData.show_sample[featureIndex]) {
      xExtent[0] = treeData.show_sample[featureIndex] - 0.2
    }
    if (xExtent[1] < treeData.show_sample[featureIndex]) {
      xExtent[1] = treeData.show_sample[featureIndex] + 0.2
    }

    const xScale = d3
      .scaleLinear()
      .domain(xExtent)
      .nice()
      .range([0, scatterplotLeafWidth]);

    /*
    d3.select(this)
      .append("g")
      .attr(
        "transform",
        `translate(${-scatterplotLeafWidth / 2 + 15}, ${scatterplotLeafHeight})`,
      )
      .call(d3.axisBottom(xScale).tickSize(0).ticks(5).tickPadding(8));
    */


    yExtent = d3.extent(treeData.data_target)

    const yScale = d3
      .scaleLinear()
      .domain(d3.extent(yExtent))
      .nice()
      .range([scatterplotLeafHeight, 0]);

    d3.select(this)
      .append("g")
      .call(
        d3.axisLeft(yScale).tickSize(0).ticks(4).tickPadding(4),
      )
      .call((d) => d.select(".domain"))
      .attr(
        "transform",
        `translate(${-scatterplotLeafWidth / 2 + 15}, 0)`,
      )
      .attr("class", "yAxis")
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none")
      .style("fill", "black");


    d3.select(this).selectAll(".domain")
      .style("stroke", "black");
    /*
    const GridLineH = function () {
        return d3.axisLeft().scale(yScale);
    };
 
    d3.select(this)
        .append("g")
        .attr("class", "st.grid")
        .call(
            GridLineH()
                .tickSize(-histogramWidth, 0, 0)
                .tickFormat("")
                .ticks(6),
        )
        .attr("transform", `translate(${-histogramWidth / 2}, ${0})`);
 
    const GridLineV = function () {
        return d3.axisBottom().scale(xScale);
    };
    d3.select(this)
        .append("g")
        .attr("class", "st.grid")
        .call(
            GridLineV()
                .tickSize(histogramHeight, 0, 0)
                .tickFormat("")
                .ticks(5),
        )
        .attr("transform", `translate(${-histogramWidth / 2}, ${0})`);
      */

    const mouseover = function(d) {
      tooltipBody.style("opacity", 1);
      d3.select(this).style("fill", "red");

      tooltipModal.style("opacity", 1);
      d3.select(this).style("fill", "red");
    };

    const mouseleave = function(d) {
      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("fill", "blue");

      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("fill", "blue");
    };

    const mouseoverline = function(d) {
      tooltipBody.style("opacity", 1);
      d3.select(this).style("stroke", "red");

      tooltipModal.style("opacity", 1);
      d3.select(this).style("stroke", "red");
    };

    const mouseleaveline = function(d) {
      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("stroke", "black");

      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("stroke", "black");
    };

    const mousemovecircle = function(event, d) {
      tooltipBody
        .html(`<b>(X,Y):</b> (${d[0]},${d[1]})`)
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipModal
        .html(`<b>(X,Y):</b> (${d[0]},${d[1]})`)
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };

    const mousemoveavarage = function(event, d) {
      tooltipBody
        .html(`<b>Avarge:</b> ${average} `)
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipModal
        .html(`<b>Avarge:</b> ${average} `)
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };

    d3.select(this)
      .append("g")
      .selectAll("g")
      .data(combinedData)
      .join("circle")
      .attr("cx", (d, i) => xScale(combinedData[i][0]))
      .attr("cy", (d, i) => yScale(combinedData[i][1]))
      .attr("r", 2)
      .attr(
        "transform",
        `translate(${-scatterplotLeafWidth / 2 + 15}, ${0})`,
      )
      .style("fill", "blue")
      .style("fill-opacity", 0.5)
      .on("mouseover", mouseover)
      .on("mouseleave", mouseleave)
      .on("mousemove", mousemovecircle);

    const xDomain = xScale.domain();


    if (!isNaN(average)) {
      d3.select(this)
        .append("line")
        .attr("class", "average-line")
        .attr("x1", 0)
        .attr("x2", scatterplotLeafWidth)
        .attr("y1", yScale(average))
        .attr("y2", yScale(average))
        .attr("stroke", "black")
        .attr(
          "transform",
          `translate(${-scatterplotLeafWidth / 2 + 15},0)`,
        )
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,5")
        .on("mouseover", mouseoverline)
        .on("mouseleave", mouseleaveline)
        .on("mousemove", mousemoveavarage);
    }

    d3.select(this)
      .append("text")
      .attr("class", "st-target")
      .attr("x", 15)
      .attr("y", rectHeight + 30)
      .style("text-anchor", "middle")
      .style("font-size", "18px")
      .text(`n = ${d.data.samples}`)
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none");

    stLog("debug", d.data.class_distribution[0][0], "dist")

    d3.select(this)
      .append("text")
      .attr("class", "st-target")
      .attr("x", 15)
      .attr("y", rectHeight + 5)
      .style("text-anchor", "middle")
      .style("font-size", "18px")
      .text(`${d.data.treeclass} = ${parseFloat(d.data.class_distribution[0][0].toFixed(3))}`)
      .style("user-select", "none")
      .style("-webkit-user-select", "none")
      .style("-moz-user-select", "none")
      .style("-ms-user-select", "none");

    stLog("info", d.data.treeclass);
    var mouseovertriangle = function(d) {


      tooltipBody.style("opacity", 1);
      tooltipModal.style("opacity", 1);

      d3.select(this).style("fill", "red").style("stroke", "red");
    };

    var mouseleavetriangle = function(d) {


      tooltipBody
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      tooltipModal
        .style("opacity", 0)
        .style("top", 0 + "px")
        .style("left", 0 + "px");

      d3.select(this).style("fill", "green")
        .style("stroke", "green");
    };


    var mousemovetriangle = function(event, d) {

      tooltipModal
        .html(
          treeData.feature_names.map((feature, index) => {
            const sampleValue = treeData.show_sample[index];
            const formattedValue = !isNaN(parseFloat(sampleValue)) ? parseFloat(sampleValue).toFixed(3) : 'N/A';
            return `<b>${feature}:</b> ${formattedValue}`;
          }).join(",")
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");

      tooltipBody
        .html(
          treeData.feature_names.map((feature, index) => {
            const sampleValue = treeData.show_sample[index];
            const formattedValue = !isNaN(parseFloat(sampleValue)) ? parseFloat(sampleValue).toFixed(3) : 'N/A';
            return `<b>${feature}:</b> ${formattedValue}`;
          }).join(",")
        )
        .style("top", event.pageY - 10 + "px")
        .style("left", event.pageX + 10 + "px");
    };


    var color = "green";
    var triangleSize = 25;

    var triangle = d3.symbol()
      .type(d3.symbolTriangle)
      .size(triangleSize);
    stLog("debug", d, "XSCALE");
    if (isSampleExistInThisNode) {
      stLog("debug", d, "Existtt");
      d3.select(this).append("path")
        .attr("d", triangle)
        .attr("class", "st-triangle")
        .style("stroke", color) 
        .style("stroke-width",1)
        .style("stroke-opacity",1)
        .style("fill", color)
        .attr("transform", function(d) {
          return "translate(" + (-scatterplotLeafWidth / 2 + 15 + xScale(treeData.show_sample[d.parent.data.feature])) + "," + scatterplotLeafHeight + ")";
        })
        .on("mouseover", mouseovertriangle)
        .on("mouseleave", mouseleavetriangle)
        .on("mousemove", mousemovetriangle);
    }
  }
}




 </script>
    